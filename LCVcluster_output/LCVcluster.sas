options symbolgen mprint mlogic;

%macro LCVcluster
   (datain=datain,subsetvr=,foldcnt=10,initseed=3,holdout=,xvrepeat=1,
    BIC=N,scretype=MIXTURE,yvars=,yprefix=,yfst=,ylst=,yby=1,clusvars=,
    stdize=N,stdrange=N,stdizace=,yvarnces=DIFF,ycorrs=DIFF,
    cvarnces=DIFF,ccorrs=SAME,near0std=0.01,near0eig=0.01,
    mindens=1e-100,methlist=WARD,nclustrs=.,minnclus=1,maxnclus=20,
    nonorm=N,notie=N,minprop=0,minsize=1,keeplevl=0.02,keeptst=Y,
    mlistord=N,printall=N,scorefmt=,decrsfmt=4,procmod=N,plotprnt=N,
    eignvals=N,listfrom=10,xtravars=,idvar=,outlib=,outtree=outtree,
    outclus=outclus,clstrvar=clusindx,aveyvars=aveyvars,begnotes=N,
    endnotes=Y,noprint=N,testcalc=N);

 /*
  invoke the LCVcluster macro to conduct cluster analyses setting
  the macro parameters to appropriate values or using the default
  values given in the macro declaration

  parameter values with special characters may need to be enclosed
  in a special macro quoting function like %quote or %str

   datain   - the name of the data set loaded with all input variables
              for the current invocation of the macro

      &datain should either be the name of a data set in the default
      library or a valid two-level SAS data set name

   subsetvr - name of the subsetting variable (default value is the
              empty specification)

      the analysis will use only those observations in the datain
      data set for which the subsetting variable has nonmissing
      and nonzero values

      an empty or missing specification means use all the observations

   foldcnt  - indicates the number of folds to use in cross-validation 
              computations

      it is recommended that the same random ordering for all models
      be used so that cross-validation scores for those models are 
      comparable

      to request a leave-one-out cross-validation, set foldcnt=n (the
      character value "n", not the actual numeric sample size)

      to request a holdout (or splitting or learning-testing) type of
      cross-validation, set foldcnt=1 and provide a value for holdout

   initseed - the initial seed for fold specification

      if it is not a positive integer, it will be changed to the largest
      integer less than the supplied value as long as that is at least 3
      and otherwise changed to 3

      it also should be < 2**31-1

      it also needs to remain unchanged so that all cross-validation scores
      are comparable, but may be changed in order to generate a repeated
      cross-validation analysis

   holdout  - the proportion of the observations to holdout for testing
              purposes

      foldcnt=1 with holdout=0.5 is like an incomplete 2-fold cross-
      validation with the LCV score computed for one of the folds 
      rather than for both

      a value of 0.5 is recommended so that the learning or training phase
      uses about the same number of observations as the testing phase

   xvrepeat - the number of times to repeat the cross-validation
              computations using different random fold allocations

   BIC    - Y (or y) means choose models on basis of Schwarz's Bayesian
              information criterion (BIC)

      the bigger is better version is used, normalized by the sample size
      so comparable to LCV scoring

      this is used for comparison to standard LCV scores and for determining
      percent decreases for model comparisons

      however, the smaller is better actual BIC score is reported as well
      for comparison to BIC scores generated by other software tools

   scretype - indicates the type of cross-validation score to compute

      EXPECTED - means use the complete data likelihood with unknown
                 cluster membership indicators variables replaced by
                 their expected values given the estimated parameters

      MIXTURE  - means to use the observed data likelihood based on a
                 mixture of normal densities over the clusters weighted by
                 proportional sizes of the clusters

      PREDICTD - means use the weighted normal density for the predicted
                 cluster for observations in a fold based on having the
                 maximum such weighted density value

         this is the same as the prediction based on using the maximum
         of the expected membership indicators variables for an
         observation

         the unweighted version of PREDICTD is not recommended, especially
         for the case cvarnces=SAME and ccorrs=SAME, when unweighted
         PREDICTD favors having many singleton clusters since they get
         assigned nonzero likelihoods this does not happen for the
         cvarnces=DIFF and ccorrs=DIFF case with unweigthed PRED but also
         does not happen in both cases for weigted PRED

      scores computed for all methods under consideration are put in
      the data set called lcvscres while the scores within keeplevl of
      the best score are put in the data set called bestscrs

   yvars    - the list of y variables to use in the cross-validation
              computations

      separate the names by blanks

      note that the data set will be sorted on the yvars in the order
      provided which can have an impact when there are tied distances
      between groups of observations considered in the clustering

   yprefix  - the prefix for the names of y variables if not specified
              directly through the yvars parameter

      all such variables must have names that start with &yprefix

      alternative to the list determined by yvars

   yfst     - the beginning index for y variable names 

   ylst     - the ending index for y variable names

   yby      - the increment for y variable names

      the variables are numbered from &yfst to &ylst 
      incremented by &yby

   clusvars - the list of variables to use in computing the clusters
              if this is different from the yvars variables

      separate the names by blanks

      when clusvars is empty, the yvars variables are used in 
      computing the clusters and the cross-validation scores, 
      otherwise the clusvars variables are used to compute the
      clusters while the yvars variables are used to compute the
      cross-validation scores

      can use for special user-standardizing of the yvars variables,
      not supported by LCVcluster

      can also be a subset of the yvars variables to assess the value
      of the other yvars variables in generating clusters

      currently no option to specify these variable names using
      a common prefix as for yvars

   stdize   - Y (or y) means cluster standardized yvars using the
              usual approach for standardizing normal variables 

      y variable values are mapped to their z scores 

   stdrange - Y (or y) means cluster standardized yvars using the
              range for each y variable

      y variable values are mapped to the unit interval [0,1] in
      such a way that the lowest/highest value is mapped to 0/1 

   stdizace - when not empty, requests standardization of the y variables
              using the approximate covariance estimation (ACE) approach

      the stdizace macro parameter value is the proportion of pairs to be
      included in the estimation of the within-cluster covariance matrix,
      for example, stdizace=0.3 is used in the example analysis provided
      in the on-line SAS help for PROC ACECLUS

   yvarnces - indicates the form for the variance structure for y variables
              to use in likelihood calculations

      all cluster variances will have the same form but possibly separate
      estimates

      DIFF     - means use different variances for different y variables

      SAME     - means use the same variance for all y variables

   ycorrs   - indicates the form for the correlation structure for y 
              variables to use in likelihood calculations

      all cluster correlations will have the same form but possibly
      separate estimates

      DIFF     - means use different correlations for different pairs of y
                 variables

      SAME     - means use the same correlation for all pairs of y variables

      ZERO     - means use a correlation of zero for all pairs of y 
                 variables

   cvarnces - indicates how the variance structure changes across clusters

      DIFF     - means use different variance estimates for different
                 clusters

      SAME     - means use the same variance estimate for all clusters

   ccorrs   - indicates how correlation structure changes across clusters

      DIFF     - means use different correlation estimates for different
                 pairs of y variables 

      SAME     - means use the same correlation estimate (or value of zero)
                 for all pairs of y variables

      if ycorrs is set to ZERO, then ccorrs must be set to SAME

      the cases with cvarnces and ccorrs both SAME and both DIFF use
      true maximum likelihood estimates and so are recommended over the
      cases with one of cvarnces and ccorrs SAME and the other DIFF
      the estimation procedures used with these latter cases need further
      development since they can generate estimated correlation matrices
      which are not nonnegative definite

   near0std - minimal value for a standard deviation

   near0eig - minimal value for an eigenvalue

   mindens  - specifies a minimum density value to avoid very low density
              values

      the value of mindens can have a large impact on the choice of the
      best number of clusters

      the choice of 1e-100 seems to provide a reasonable tradeoff between
      not changing nonzero density values too much while avoiding zero
      density values

   methlist - a list of cluster extraction methods of the following
              types separated by blanks

      the order of preference for use with keeplevl is determined by
      mlistord

      only 4 of the methods have adjusted versions with distances not
      squared because all other methods are unaffected by that adjustment

      AVERAGE is the average linkage method

      AVERNOSQ is the average linkage method with distances not squared

      CENTROID is the centroid method

      CENTNOSQ is the centroid method with distances not squared

      COMPLETE is the complete linkage method

      DENSNN:k is the nearest neighbor density linkage method 

         k is set to the desired number of nearest neighbors with
         2 <= k < the number of observations
      
      DENSSS:x is the sphere of support density linkage method 

         x is set to the desired radius for the sphere of support
         with x > 0

         this method can produce the error message that "similarity
         or dissimilarity could not be determined" when x is too small

      EML is the maximum likelihood method with default penalty of 2

      EML:p is the maximum likelihood method with penalty=p

         the penalty should be a positive integer

      FLEXIBLE is the default Lance-Williams flexible-beta method

         beta by default is -0.25

      FLEX:b is the Lance-Williams flexible-beta method with beta=b

         beta should be <1, usually between -1 and 0

         beta=-0.5 recommended by Milligan for data with many outliers

      KMEANS is the k-means method

      MCQUITTY is McQuitty's similarity analysis

      MEDIAN is Gower's median method

      MEDNNOSQ is Gower's median method with distances not squared

      SINGLE is the single linkage method

      WARD is Ward's minimum variance method

      WARDNOSQ is Ward's minimum variance method with distances not squared

      2STGNN:k is the two-stage nearest neighbor density linkage method

         k is set to the desired number of nearest neighbors with
         2 <= k < the number of observations

      2STGSS:x is the two-stage sphere of support density linkage method 

         x is set to the desired radius for the sphere of support
         with x > 0
      
         this method can produce the error message that "similarity
         or dissimilarity could not be determined" when x is too small

   nclustrs - set to the number of clusters to be extracted
              or set to . to request estimation of the number of clusters

   minnclus - set to the minimum number of clusters to be extracted 
              when the number of clusters is to be estimated

   maxnclus - set to the maximum number of clusters to be extracted 
              when the number of clusters is to be estimated

   nonorm   - Y (or y) means do not normalize distances 

   notie    - Y (or y) means do not have PROC CLUSTER check for ties for
              minimum distance between lower level clusters when forming
              higher level clusters 

   minprop  - minimum cluster size proportion

      a clustering alternative is dropped from consideration if the
      proportion for its smallest cluster is less than minprop

   minsize  - minimum cluster size 

      a clustering alternative is dropped from consideration if the
      size of its smallest cluster size is less than minsize

   keeplevl - keep only those modeling methods with scores within
              keeplevl*100% of the best score

      when methlist has more than one method, the order those methods
      are listed determines which one will be passed to PROC CLUSTER
      when procmod=Y

      method and number of cluster combinations with scores within
      keeplevl of best are sorted first by number of clusters and 
      then by method to determine the parsimonious, nearly optimal
      choice to pass to PROC CLUSTER

      the combined decrease using the average score over all &xvrepeat
      repetitions of the cross-validation is used in general for deciding
      which methods to keep which is the same as the separate decrease
      when &xvrepeat=1, but separate decreases are computed in the
      general case as well

   keeptst  - set to Y (or y) to generate the value of keeplevl corresponding
              to testing whether the log of the ratio of the unnormalized
              (i.e., not raised to power = the number of observations) LCV
              scores exceed the 95th percentile of the chi-square 
              distribution with 1 degree of freedom, i.e, the analogue to the
              likelihood ratio test applied to LCV scores

              for this approach, keeplevl is just below 0.02 at n=96, and
              would exceed 0.02 for n<=95, however, the asymptotic
              approximation needed to use a chi-square distribution becomes
              questionable as n decreases, consequently, keeplevl is set to
              0.02 for n<=95

   mlistord - Y (or y) means the order of preference for use with 
              keeplevl is determined by the order methods appear in
              the list for any fixed number of clusters

      N means the LCV score determines the order of preference for
      any fixed number of clusters

   printall - Y (or y) means to print scores for all modeling
              methods not just the ones with scores within keeplevl

   scorefmt - the number of digits to round LCV scores in the output

      an empty setting means to allow SAS to automatically choose
      the format

   decrsfmt - the number of digits to round proportional decreases
              in LCV scores in the output

      an empty setting means to allow SAS to automatically choose
      the format

   procmod  - Y (or y) means to generate an equivalent model for
              the full data set using SAS PROC CLUSTER or PROC FASTCLUS

      the smallest number of clusters within keeplevl of best
      will be used

      3 output data sets are created

         &outtree containing information on the tree of all numbers of
         clusters (but not for the KMEANS clustering procedure)

         &outclus containing information on the extracted clusters

         &aveyvars containing averages of &yvars variables for the
         extracted clusters

   plotprnt - Y (or y) means to generate plots for each pair of y variables
              with points ploted using indexes for their cluster menmbership

   eignvals - Y (or y) means to generate the eignevalues in the output of
              PROC CLUSTER if procmod is requested

   listfrom - the starting number of clusters for the output of PROC CLUSTER
              data sets if procmod=Y is requested (the setting for the PRINT=
              option for PROC CLUSTER)

      a value of zero means produce output for none of the clusters

   xtravars - list of names of extra variables to copy to output
              data sets if procmod=Y is requested

   outlib   - the name of the library to be loaded with permanent copies of
              the outtree, outclus, and aveyvars data sets

   idvar    - the name of a single variable to serve as the ID for 
              for observations in output data sets for procmod=Y 

   outtree  - the name to be assigned to the data set containing the tree 
              representation of the output of PROC CLUSTER

      if multiple methods and numbers of clusters are considered, the one
      with the best score will be used

      if the best method is KMEANS, no outtree data set is produced

      the structure of this data set is controlled by PROC TREE

   outclus  - the name to be assigned to the dta set containing the 
              cluster assignments computed from the outtree data set
              using PROC TREE or directly by PROC FASTCLUS for the
              KMEANS method

      if multiple methods and numbers of clusters are considered, the one
      with the best score will be used

      contains the following variables, one record per subject

        &idvar  - the variable containing subject IDs
        _freq_  - with numbers of subjects within clusters
        &yvars  - with values of each yvars variable (or as determined 
                  by &yprefix, &yfst, &ylst, and &yby) for subjects
        cluster - with cluster indexes

   clstrvar - the name to be assigned to the variable of the outclus data set
              to contain the indexes of the clusters for subjects

   aveyvars - the name to be assigned to the dta set containing 
              averages of the yvars variables for subjects within
              the clusters 

      if multiple methods and numbers of clusters are considered, the one
      with the best score will be used

      contains the following variables, one record per cluster

        cluster - with cluster indexes
        _freq_  - with numbers of subjects within clusters
        &yvars  - with averages of each yvars variable (or as determined 
                  by &yprefix, &yfst, &ylst, and &yby) over subjects
                  within each cluster

   begnotes - set to and value other than Y (meaning N) to shut off 
              printing in the log area of note messages by SAS 
              procedures executed by the macro

      the value N is used when testing new versions of the macro

      its value is not error checked so that Y means turn on printing
      to the log and any other value means turm off that printing

   endnotes - set to any other value than N (menaing Y) to turn on 
              printing in the log area of note messages by SAS
              procedures after macro execution stops

      its value is not error checked so that Y means turn on printing
      to the log and any other value means turm off that printing

      its value is not error checked so that N means turn off printing
      to the log and any other value means turm on that printing

   noprint  - Y (or y) means to turn off printing of all output

      the procmod options are ignored

      error messages if any will still be printed

   testcalc - Y (or y) means to turn off printing of LCV calculations
              for test purposes

 */

 %let abort=0;
 %if %upcase(&begnotes)=Y %then %do;
  options notes;
 %end;
 %else %do;
  options nonotes;
 %end;
 proc contents data=&datain out=datacnt noprint;
 run;
 data datacnt;
  set datacnt;
  if _n_=1;
  call symput("datacnt",compress(nobs));
 run;
 proc iml symsize=4000 worksize=4000;
  reset noname; * turn off when testing so names come out in prints;
  inpterr=0;
  dsfound=0;
  %let part1=%scan(&datain,1,.);
  %let part2=%scan(&datain,2,.);
  %if &part2= %then %do;
   dslist=datasets();
   dsname="%upcase(&part1)";
   lbname="";
  %end;
  %else %do;
   dslist=datasets(&part1);
   lbname="%upcase(&part1)";
   dsname="%upcase(&part2)";
  %end;
  if any(dslist=dsname) then
   dsfound=1;
  if ^dsfound then do;
   print "nonexistent data set &datain";
   inpterr=1;
  end;
  else do;
   %if &part2= %then %do;
    dsvars=contents(dsname);
   %end;
   %else %do;
    dsvars=contents(lbname,dsname);
   %end;
   * print dsvars;
   dsvars=upcase(dsvars);
   %if %quote(&subsetvr)^= & %quote(&subsetvr)^=. %then %do;
    if all(dsvars^="%upcase(&subsetvr)") then do;
     print "nonexistent subsetting variable: &subsetvr";
     inpterr=1;
    end;
   %end;
   %let yvarcnt=1;
   %let yvarnext=%qscan(&yvars,&yvarcnt,%str( ));
   %let yvnamerr=0;
   %do %while (&yvarnext^=);
    if all(dsvars^="%upcase(&yvarnext)") then do;
     print (concat("nonexistent yvars variable: ","&yvarnext"));
     inpterr=1;
    end;
    %let yvarcnt=%eval(&yvarcnt+1);
    %let yvarnext=%qscan(&yvars,&yvarcnt,%str( ));
   %end;
   %let yvarcnt=%eval(&yvarcnt-1);
   %let cluscnt=1;
   %let clusnext=%qscan(&clusvars,&cluscnt,%str( ));
   %let cvnamerr=0;
   %do %while (&clusnext^=);
    if all(dsvars^="%upcase(&clusnext)") then do;
     print (concat("nonexistent clusvars variable: ","&clusnext"));
     inpterr=1;
    end;
    %let cluscnt=%eval(&cluscnt+1);
    %let clusnext=%qscan(&clusvars,&cluscnt,%str( ));
   %end;
   %let cluscnt=%eval(&cluscnt-1);
  end;
  %if %quote(&near0std)^= %then %do;
   %if %datatyp(&near0std)^=NUMERIC %then %do;
    print "near0std (&near0std) not numeric";
    inpterr=1;
   %end;
   %else %do;
    near0std=&near0std;
    if near0std<=0 then do;
     print "near0std (&near0std) not positive";
     inpterr=1;
    end;
   %end;
  %end;
  %if %quote(&near0eig)^= %then %do;
   %if %datatyp(&near0eig)^=NUMERIC %then %do;
    print "near0eig (&near0eig) not numeric";
    inpterr=1;
   %end;
   %else %do;
    near0eig=&near0eig;
    if near0eig<=0 then do;
     print "near0eig (&near0eig) not positive";
     inpterr=1;
    end;
   %end;
  %end;
  %if %quote(&mindens)^= %then %do;
   %if %datatyp(&mindens)^=NUMERIC %then %do;
    print "mindens (&mindens) not numeric";
    inpterr=1;
   %end;
   %else %do;
    mindens=&mindens;
    if mindens<=0 then do;
     print "mindens (&mindens) not positive";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&decrsfmt)^=NUMERIC %then %do;
   print "decrsfmt (&decrsfmt) not numeric";
   inpterr=1;
  %end;
  %else %do;
   decrsfmt=&decrsfmt;
   if decrsfmt<0 then do;
    print "decrsfmt (&decrsfmt) is negative";
    inpterr=1;
   end;
   else if mod(decrsfmt,int(decrsfmt))^=0 then do;
    print "decrsfmt (&decrsfmt) not an integer";
    inpterr=1;
   end;
  %end;

  %if %quote(&scorefmt)^= %then %do;
   %let sfmtfrst=%qscan(&scorefmt,1,.);
   sfm1err=0;
   %if %quote(&sfmtfrst)= %then %do;
    print scorefmt (&scorefmt) is not a w.d format;
    inpterr=1;
    sfm1err=1;
   %end;
   %else %if %datatyp(&sfmtfrst)^=NUMERIC %then %do;
    print "first part of scorefmt (&sfmtfrst) not numeric";
    inpterr=1;
    sfm1err=1;
   %end;
   %else %do;
    sfmtfrst=&sfmtfrst;
    if sfmtfrst<=0 then do;
     print "first part of scorefmt (&sfmtfrst) is not positive";
     inpterr=1;
    sfm1err=1;
    end;
    else if mod(sfmtfrst,int(sfmtfrst))^=0 then do;
     print "first part of scorefmt (&sfmtfrst) not an integer";
     inpterr=1;
    sfm1err=1;
    end;
   %end;
   %let sfmtscnd=%qscan(&scorefmt,2,.);
   %if %quote(&sfmtscnd)= %then %do;
    print scorefmt (&scorefmt) is not a w.d format;
    inpterr=1;
   %end;
   %else %if %datatyp(&sfmtscnd)^=NUMERIC %then %do;
    print "second part of scorefmt (&sfmtscnd) not numeric";
    inpterr=1;
   %end;
   %else %do;
    sfmtscnd=&sfmtscnd;
    if sfmtscnd<0 then do;
     print "second part of scorefmt (&sfmtscnd) is negative";
     inpterr=1;
    end;
    else if mod(sfmtscnd,int(sfmtscnd))^=0 then do;
     print "second part of scorefmt (&sfmtscnd) not an integer";
     inpterr=1;
    end;
   %end;
  %end;

  %let frstchar=ABCDEFGHIJKLMNOPQRSTUVWXYZ_;
  %let othrchar=&frstchar.0123456789;
  %let parm=outtree;
  %let SASname=%upcase(&outtree);
  %if %quote(&SASname)^= %then %do;
   %if %verify(%substr(&SASname,1,1),&frstchar)>0 %then %do;
    print "first character of &parm setting not alphabetic or an underscore";
    inpterr=1;
   %end;
   %else %if %verify(&SASname,&othrchar)>0 %then %do;
    print "&parm setting not a valid SAS name";
    inpterr=1;
   %end;
   %if %length(&SASname)>32 %then %do;
    print "&parm setting is longer than 32 characters";
    inpterr=1;
   %end;
  %end;
  %else %do;
   print "empty specification for &parm not allowed";
   inpterr=1;
  %end;
  %let parm=outclus;
  %let SASname=%upcase(&outclus);
  %if %quote(&SASname)^= %then %do;
   %if %verify(%substr(&SASname,1,1),&frstchar)>0 %then %do;
    print "first character of &parm setting not alphabetic or an underscore";
    inpterr=1;
   %end;
   %else %if %verify(&SASname,&othrchar)>0 %then %do;
    print "&parm setting not a valid SAS name";
    inpterr=1;
   %end;
   %if %length(&SASname)>32 %then %do;
    print "&parm setting is longer than 32 characters";
    inpterr=1;
   %end;
  %end;
  %else %do;
   print "empty specification for &parm not allowed";
   inpterr=1;
  %end;
  %let parm=clstrvar;
  %let SASname=%upcase(&clstrvar);
  %if %quote(&SASname)^= %then %do;
   %if %verify(%substr(&SASname,1,1),&frstchar)>0 %then %do;
    print "first character of &parm setting not alphabetic or an underscore";
    inpterr=1;
   %end;
   %else %if %verify(&SASname,&othrchar)>0 %then %do;
    print "&parm setting not a valid SAS name";
    inpterr=1;
   %end;
   %if %length(&SASname)>32 %then %do;
    print "&parm setting is longer than 32 characters";
    inpterr=1;
   %end;
  %end;
  %else %do;
   print "empty specification for &parm not allowed";
   inpterr=1;
  %end;
  %let parm=aveyvars;
  %let SASname=%upcase(&aveyvars);
  %if %quote(&SASname)^= %then %do;
   %if %verify(%substr(&SASname,1,1),&frstchar)>0 %then %do;
    print "first character of &parm setting not alphabetic or an underscore";
    inpterr=1;
   %end;
   %else %if %verify(&SASname,&othrchar)>0 %then %do;
    print "&parm setting not a valid SAS name";
    inpterr=1;
   %end;
   %if %length(&SASname)>32 %then %do;
    print "&parm setting is longer than 32 characters";
    inpterr=1;
   %end;
  %end;
  %else %do;
   print "empty specification for &parm not allowed";
   inpterr=1;
  %end;
  %if %datatyp(&initseed)^=NUMERIC %then %do;
   print "initseed (&initseed) not numeric";
   inpterr=1;
  %end;
  %else %do;
   initseed=&initseed;
   if initseed<3 then do;
    print "initseed (&initseed) less than 3";
    inpterr=1;
   end;
   else if mod(initseed,int(initseed))^=0 then do;
    print "initseed (&initseed) not an integer";
    inpterr=1;
   end;
  %end;
  %if %upcase(&BIC)^=Y & %upcase(&BIC)^=N %then %do;
   print "BIC (&BIC) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if &xvrepeat^=1 & %upcase(&BIC)=Y %then %do;
    print "BIC only supported with xvrepeat=1";
    inpterr=1;
   %end;
   %if %upcase(&scretype)=PREDICTED & %upcase(&BIC)=Y %then %do;
    print 
  "Warning. BIC counts # of cluster proportions which may be inappropriate";
   %end;
  %end;
  %if %upcase(&scretype)^=EXPECTED & %upcase(&scretype)^=MIXTURE &
      %upcase(&scretype)^=PREDICTD
  %then %do;
   print "scretype (&scretype) not EXPECTED, MIXTURE, or PREDICTD";
   inpterr=1;
  %end;
  %if %upcase(&yvarnces)^=DIFF & %upcase(&yvarnces)^=SAME %then %do;
   print "yvarnces (&yvarnces) not DIFF or SAME";
   inpterr=1;
  %end;
  %if %upcase(&ycorrs)^=DIFF & %upcase(&ycorrs)^=SAME & 
      %upcase(&ycorrs)^=ZERO
  %then %do;
   print "ycorrs (&ycorrs) not DIFF, SAME, or ZERO";
   inpterr=1;
  %end;
  %if %upcase(&cvarnces)^=DIFF & %upcase(&cvarnces)^=SAME %then %do;
   print "cvarnces (&cvarnces) not DIFF or SAME";
   inpterr=1;
  %end;
  %if %upcase(&ccorrs)^=DIFF & %upcase(&ccorrs)^=SAME %then %do;
   print "ccorrs (&ccorrs) not DIFF or SAME";
   inpterr=1;
  %end;
  %if %upcase(&ycorrs)=ZERO & %upcase(&ccorrs)=DIFF %then %do;
   print "ycorrs=ZERO requires ccorrs=SAME";
   inpterr=1;
  %end;
  %if %upcase(&stdize)^=Y & %upcase(&stdize)^=N %then %do;
   print "stdize (&stdize) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if %quote(&clusvars)^= & %upcase(&stdize)=Y %then %do;
    print "clusvars non-empty not supported with stdize=Y";
    inpterr=1;
   %end;
   %if %quote(&stdizace)^= & %upcase(&stdize)=Y %then %do;
    print "stdizace non-empty not supported with stdize=Y";
    inpterr=1;
   %end;
   %if %quote(&stdrange)=Y & %upcase(&stdize)=Y %then %do;
    print "stdrange=Y not supported with stdize=Y";
    inpterr=1;
   %end;
  %end;
  %if %upcase(&stdrange)^=Y & %upcase(&stdrange)^=N %then %do;
   print "stdrange (&stdrange) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if %quote(&clusvars)^= & %upcase(&stdrange)=Y %then %do;
    print "clusvars not supported with stdrange=Y";
    inpterr=1;
   %end;
   %if %quote(&stdizace)^= & %upcase(&stdrange)=Y %then %do;
    print "stdizace non-empty not supported with stdrange=Y";
    inpterr=1;
   %end;
  %end;
  %if %quote(&stdizace)^= %then %do;
   %if %datatyp(&stdizace)^=NUMERIC %then %do;
    print "stdizace (&stdizace) nonnumeric";
    inpterr=1;
   %end;
   %else %do;
    stdizace=&stdizace;
    if stdizace<=0 | stdizace>=1 then do;
     print "stdizace (&stdizace) must be > 0 and < 1";
     inpterr=1;
    end;
   %end;
  %end;
  %if %upcase(&nonorm)^=Y & %upcase(&nonorm)^=N %then %do;
   print "nonorm (&nonorm) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&notie)^=Y & %upcase(&notie)^=N %then %do;
   print "notie (&notie) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&noprint)^=Y & %upcase(&noprint)^=N %then %do;
   print "noprint (&noprint) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&printall)^=Y & %upcase(&printall)^=N %then %do;
   print "printall (&printall) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&printall)=Y & %upcase(&noprint)=Y %then %do;
   print "printall (&printall) inconsistent with noprint (&noprint)";
   inpterr=1;
  %end;
  %if %upcase(&plotprnt)^=Y & %upcase(&plotprnt)^=N %then %do;
   print "plotprnt (&plotprnt) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&eignvals)^=Y & %upcase(&eignvals)^=N %then %do;
   print "eignvals (&eignvals) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&procmod)^=Y & %upcase(&procmod)^=N %then %do;
   print "procmod (&procmod) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if %quote(&xtravars)^= & %upcase(&procmod)=N %then %do;
    print "xtravars not empty but procmod=N";
    inpterr=1;
   %end;
   %if %upcase(&plotprnt)=Y & %upcase(&procmod)=N %then %do;
    print "plotprnt=Y but procmod=N";
    inpterr=1;
   %end;
   %if %upcase(&eignvals)=Y & %upcase(&procmod)=N %then %do;
    print "eignvals=Y but procmod=N";
    inpterr=1;
   %end;
  %end;
  %if %upcase(&testcalc)^=Y & %upcase(&testcalc)^=N %then %do;
   print "testcalc (&testcalc) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&mlistord)^=Y & %upcase(&mlistord)^=N %then %do;
   print "mlistord (&mlistord) not Y or N";
   inpterr=1;
  %end;
  %if &foldcnt=n %then %do;
   foldcnt=&datacnt;
  %end;
  %else %if %datatyp(&foldcnt)^=NUMERIC %then %do;
   print "foldcnt (&foldcnt) nonnumeric but not equal to n";
   inpterr=1;
  %end;
  %else %do;
   foldcnt=&foldcnt;
   if foldcnt<1 then do;
    print "foldcnt (&foldcnt) less than 1";
    inpterr=1;
   end;
   else if mod(foldcnt,int(foldcnt))^=0 then do;
    print "foldcnt (&foldcnt) not an integer";
    inpterr=1;
   end;
  %end;
  %if %quote(&holdout)^= %then %do;
   %if &foldcnt^=1 %then %do;
    print "holdout (&holdout) not supported with foldcnt^=1";
    inpterr=1;
   %end;
   %if %datatyp(&holdout)^=NUMERIC %then %do;
    print "holdout (&holdout) nonnumeric";
    inpterr=1;
   %end;
   %else %do;
    holdout=&holdout;
    if holdout<=0 | holdout>=1 then do;
     print "holdout (&holdout) must be > 0 and < 1";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&xvrepeat)^=NUMERIC %then %do;
   print "xvrepeat (&xvrepeat) nonnumeric";
   inpterr=1;
  %end;
  %else %do;
   xvrepeat=&xvrepeat;
   if xvrepeat<1 then do;
    print "xvrepeat (&xvrepeat) less than 1";
    inpterr=1;
   end;
   else if mod(xvrepeat,int(xvrepeat))^=0 then do;
    print "xvrepeat (&xvrepeat) not an integer";
    inpterr=1;
   end;
   else if xvrepeat>1 & "%upcase(&foldcnt)"="N" then do;
    print "leave-one-out cross-validation requires xvrepeat=1";
    inpterr=1;
   end;
   %if %upcase(&testcalc)=Y %then %do;
    if xvrepeat>2 then do;
     print "testcalc=Y not allowed with xvrepeat>2 to limit output";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&nclustrs)^=NUMERIC & &nclustrs^=. %then %do;
   print "nclustrs (&nclustrs) not numeric";
   inpterr=1;
  %end;
  %else %do;
   nclustrs=&nclustrs;
   if nclustrs^=. then do;
    if nclustrs<1 then do;
     print "nclustrs (&nclustrs) not at least 1";
     inpterr=1;
    end;
    else if mod(nclustrs,int(nclustrs))^=0 then do;
     print "nclustrs (&nclustrs) not an integer";
     inpterr=1;
    end; 
   end;
   %if %upcase(&testcalc)=Y %then %do;
    if nclustrs=. then do;
     print "testcalc=Y not allowed with nclustrs=. to limit output";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&maxnclus)^=NUMERIC %then %do;
   print "maxnclus (&maxnclus) not numeric";
   inpterr=1;
   maxnclus=.;
  %end;
  %else %do;
   maxnclus=&maxnclus;
   if maxnclus<=0 then do;
    print "maxnclus (&maxnclus) not positive";
    inpterr=1;
   end;
   else do;
    if mod(maxnclus,int(maxnclus))^=0 then do;
     print "maxnclus (&maxnclus) not an integer";
     inpterr=1;
    end;
   end;
  %end;
  %if %datatyp(&maxnclus)^=NUMERIC %then %do;
   print "minnclus (&minnclus) not numeric";
   inpterr=1;
  %end;
  %else %do;
   minnclus=&minnclus;
   if minnclus<=0 then do;
    print "minnclus (&maxnclus) not positive";
    inpterr=1;
   end;
   else do;
    if mod(minnclus,int(minnclus))^=0 then do;
     print "minnclus (&minnclus) not an integer";
     inpterr=1;
    end;
    else if maxnclus^=. then do;
     if minnclus>maxnclus then do;
      print "minnclus (&minnclus) exceeds maxnclus (&maxnclus)";
      inpterr=1;
     end;
    end;
   end;
  %end;
  %if %datatyp(&minprop)^=NUMERIC %then %do;
   print "minprop (&minprop) nonnumeric";
   inpterr=1;
  %end;
  %else %do;
   minprop=&minprop;
   if minprop<0 | minprop>=1 then do;
    print "minprpo (&minprop) must be >= 0 and < 1";
    inpterr=1;
   end;
  %end;
  %if %datatyp(&minsize)^=NUMERIC %then %do;
   print "minsize (&minsize) nonnumeric";
   inpterr=1;
  %end;
  %else %do;
   minsize=&minsize;
   if minsize<1 then do;
    print "minsize (&minsize) less than 1";
    inpterr=1;
   end;
   else if mod(minsize,int(minsize))^=0 then do;
    print "minsize (&minsize) not an integer";
    inpterr=1;
   end;
  %end;
  %if %datatyp(&keeplevl)^=NUMERIC %then %do;
   print "keeplevl (&keeplevl) not numeric";
   inpterr=1;
  %end;
  %else %do;
   keeplevl=&keeplevl;
   if keeplevl<0 then do;
    print "keeplevl (&keeplevl) is negative";
    inpterr=1;
   end;
   else do;
    if keeplevl>1 then do;
     print "keeplevl (&keeplevl) exceeds 1";
     inpterr=1;
    end;
   end;
  %end;
  %if %upcase(&keeptst)^=Y & %upcase(&keeptst)^=N %then %do;
   print "keeptst (&keeptst) not Y or N";
   inpterr=1;
  %end;
  %if %datatyp(&listfrom)^=NUMERIC %then %do;
   print "listfrom (&listfrom) not numeric";
   inpterr=1;
  %end;
  %else %do;
   listfrom=&listfrom;
   if listfrom<0 then do;
    print "listfrom (&listfrom) is negative";
    inpterr=1;
   end;
   else if mod(listfrom,int(listfrom))^=0 then do;
    print "listfrom (&listfrom) not an integer";
    inpterr=1;
   end;
  %end;
  %if %quote(&outtree)= %then %do;
   print "outtree value is empty";
   inpterr=1;
  %end;
  %else %do;
   frstchar="%upcase(%substr(&outtree,1,1))";
   if frstchar<"A" | frstchar>"Z" then do;
    print "outtree (&outtree) does not start with a letter";
    inpterr=1;
   end;
   * should also not contain special characters other than the underscore;
  %end;
  %if %quote(&outclus)= %then %do;
   print "outclus value is empty";
   inpterr=1;
  %end;
  %else %do;
   frstchar="%upcase(%substr(&outclus,1,1))";
   if frstchar<"A" | frstchar>"Z" then do;
    print "outclus (&outclus) does not start with a letter";
    inpterr=1;
   end;
   * should also not contain special characters other than the underscore;
  %end;
  methods="            "; * 12 blanks;
  %let methcnt=1;
  %let methnext=%qscan(&methlist,&methcnt,%str( ));
  %if %quote(&methnext)= %then %do;
   print "methlist is empty";
   inpterr=1;
  %end;
  EMLreqst=0;
  %do %while (%quote(&methnext)^=);
   method="%upcase(&methnext)          ";
   if method="EML" | substr(method,1,4)="EML:" then do;
    EMLreqst=1;
   end;
   methods=methods//method;
   if method^="AVERAGE" & method^="AVERNOSQ" & method^="CENTROID" &
      method^="CENTNOSQ" & method^="COMPLETE" &
      substr(method,1,7)^="DENSNN:" & substr(method,1,7)^="DENSSS:" &
      method^="EML" & method^="FLEXIBLE" & substr(method,1,4)^="EML:" &
      substr(method,1,5)^="FLEX:" & method^="KMEANS" & 
      method^="MCQUITTY" & method^="MEDIAN" & method^="MEDNNOSQ" &
      method^="SINGLE" & substr(method,1,7)^="2STGNN:" &
      substr(method,1,7)^="2STGSS:" & method^="WARD" &
      method^="WARDNOSQ"  
   then do;
    print "invalid method (&methnext)";
    inpterr=1;
   end;
   else do;
    %if %qupcase(%quote(&methnext))=KMEANS %then %do;
     %if %upcase(&notie)=Y %then %do;
      print "notie=Y not supported with the KMEANS method";
      inpterr=1;
     %end;
     %if %upcase(&nonorm)=Y %then %do;
      print "nonorm=Y not supported with the KMEANS method";
      inpterr=1;
     %end;
     %if %upcase(&eignvals)=Y %then %do;
      print "eignvals=Y not supported with the KMEANS method";
      inpterr=1;
     %end;
     %if %quote(&xtravars)^= %then %do;
      print "specifying xtravars not supported with the KMEANS method";
      inpterr=1;
     %end;
    %end;
    %if %qupcase(%quote(&methnext))=EML: %then %do;
     print "method EML: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=FLEX: %then %do;
     print "method FLEX: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=DENSNN: %then %do;
     print "method DENSNN: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=DENSSS: %then %do;
     print "method DENSSS: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=2STGNN: %then %do;
     print "method 2STGNN: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=2STGSS: %then %do;
     print "method 2STGSS: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %do;
     %if %length(&methnext)>4 %then %do;
      %if %qupcase(%substr(%quote(&methnext),1,4))=EML: %then %do;
       %if %datatyp(%substr(&methnext,5))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        penalty=%substr(&methnext,5);
        if penalty<=0 then do;
         print "penalty in &methnext not positive";
         inpterr=1;
        end;
        else if mod(penalty,int(penalty))^=0 then do;
         print "penalty in &methnext not an integer";
         inpterr=1;
        end; 
       %end;
      %end;
     %end;
     %if %length(&methnext)>5 %then %do;
      %if %qupcase(%substr(%quote(&methnext),1,5))=FLEX: %then %do;
       %if %datatyp(%substr(&methnext,6))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        betaval=%substr(&methnext,6);
        if betaval>=1 then do;
         print "beta value in &methnext not less than 1";
         inpterr=1;
        end;
       %end;
      %end;
     %end;
     %if %length(&methnext)>7 %then %do;
      %if %qupcase(%substr(%quote(&methnext),1,7))=DENSNN: |
          %qupcase(%substr(%quote(&methnext),1,7))=2STGNN:
      %then %do;
       %if %datatyp(%substr(&methnext,8))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        nearnbrs=%substr(&methnext,8);
        if nearnbrs<2 then do;
         print "# of nearest neighbors in &methnext not at least 2";
         inpterr=1;
        end;
        else if mod(nearnbrs,int(nearnbrs))^=0 then do;
         print "# of nearest neighbors in &methnext not an integer";
         inpterr=1;
        end; 
       %end;
       * note that nearnbrs should also be < the # of observations;
      %end;
      %if %qupcase(%substr(%quote(&methnext),1,7))=DENSSS: |
          %qupcase(%substr(%quote(&methnext),1,7))=2STGSS:
      %then %do;
       %if %datatyp(%substr(&methnext,8))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        sphrsupp=%substr(&methnext,8);
        if sphrsupp<=0 then do;
         print "radius of sphere of support in &methnext not positive";
         inpterr=1;
        end;
       %end;
      %end;
     %end;
    %end;
   end;
   %let methcnt=%eval(&methcnt+1);
   %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
  %end;
  %let methcnt=%eval(&methcnt-1);
  methods=methods[2:nrow(methods)];
  %if &methcnt>1 %then %do;
   uniqmeth=unique(methods);
   if nrow(methods)^=ncol(uniqmeth) then do;
    print "methlist has duplicate entries";
    inpterr=1;
   end;
   %if %upcase(&testcalc)=Y %then %do;
    print "testcalc=Y only allowed with 1 method to limit output":
    inpterr=1;
   %end;
  %end;
  %if %quote(&yvars)^= %then %do;
   %if %quote(&yfst)^= %then %do;
    print "yvars set, but yfst (&yfst) has a value";
    inpterr=1;
   %end; 
   %if %quote(&ylst)^= %then %do;
    print "yvars set, but ylst (&ylst) has a value";
    inpterr=1;
   %end;
   %if %quote(&yby)^=1 %then %do;
    print 
     "yvars set, but yby (&yby) has a value other than its default of 1";
    inpterr=1;
   %end;
   %if %quote(&yprefix)^= %then %do;
    print "yvars set, but yprefix (&yprefix) has a value";
    inpterr=1;
   %end; 
  %end;
  %else %do;
   %let allset=1;
   %if %quote(&yfst)= %then %do;
    print "no yvars list, but yfst has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %if %datatyp(&yfst)^=NUMERIC %then %do;
    print "yfst (&yfst) not numeric";
    inpterr=1;
    %let allset=0;
   %end;
   %else %if &yfst=. %then %do;
    print "yfst (&yfst) has missing value";
    inpterr=1;
    %let allset=0;
   %end;
   %if %quote(&ylst)= %then %do;
    print "no yvars list, but ylst has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %if %datatyp(&ylst)^=NUMERIC %then %do;
    print "ylst (&ylst) not numeric";
    inpterr=1;
    %let allset=0;
   %end;
   %else %if &ylst=. %then %do;
    print "ylst (&ylst) has missing value";
    inpterr=1;
    %let allset=0;
   %end;
   %if %quote(&yby)= %then %do;
    print "no yvars list, but yby has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %if %datatyp(&yby)^=NUMERIC %then %do;
    print "yby (&yby) not numeric";
    inpterr=1;
    %let allset=0;
   %end;
   %else %if &yby=. %then %do;
    print "yby (&yby) has missing value";
    inpterr=1;
    %let allset=0;
   %end;
   %if %quote(&yprefix)= %then %do;
    print "no yvars list, but yprefix has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %do;
    fstchar="%upcase(%substr(&yprefix,1,1))";
    if fstchar<"A" | fstchar>"Z" then do;
     print "yprefix (&yprefix) does not start with a letter";
     inpterr=1;
    end;
   %end;
   %if &allset %then %do;
    yfst=&yfst;
    yfsterr=0;
    if yfst<0 then do;
     print "yfst (&yfst) less than 0";
     inpterr=1;
     yfsterr=1;
    end;
    else if mod(yfst,int(yfst))^=0 then do;
     print "yfst (&yfst) not an integer";
     inpterr=1;
     yfsterr=1;
    end;
    yby=&yby;
    ybyerr=0;
    if yby<0 then do;
     print "yby (&yby) less than 0";
     inpterr=1;
     ybyerr=1;
    end;
    else if mod(yby,int(yby))^=0 then do;
     print "yby (&yby) not an integer";
     inpterr=1;
     ybyerr=1;
    end;
    ylst=&ylst;
    if ylst<=0 then do;
     print "ylst (&ylst) not positive";
     inpterr=1;
    end;
    else do;
     if mod(ylst,int(ylst))^=0 then do;
      print "ylst (&ylst) not an integer";
      inpterr=1;
     end;
     else if ^yfsterr & ^ybyerr then do;
      if yfst>ylst then do;
       print "yfst (&yfst) larger than ylst (&ylst)";
       inpterr=1;
      end;
      else if dsfound then do;
       %let yvars=;
       %do if=&yfst %to &ylst %by &yby;
        if all(dsvars^="%upcase(&yprefix.&if)") then do;
         print (concat("nonexistent yprefix variable: ","&yprefix.&if"));
         inpterr=1;
        end;
        %let yvars=&yvars &yprefix.&if;
       %end;
      end;
     end;
    end;
   %end;
  %end;
  abort=inpterr;
  call symput("abort",compress(char(abort)));
  call symput("EMLreqst",compress(char(EMLreqst)));
 quit;
 %if ^&abort %then %do;
  %if &nclustrs=. %then %do;
   %let nfst=&minnclus;
   %let nlst=&maxnclus;
  %end;
  %else %do;
   %let nfst=&nclustrs;
   %let nlst=&nclustrs;
  %end;
  %if %upcase(&BIC)=Y %then %do;
   %let foldsize=1;
  %end;
  %else %if &foldcnt=n %then %do;
   %let foldsize=&datacnt;
  %end;
  %else %do;
   %let foldsize=&foldcnt;
  %end;
  data lcvclsin;
   set &datain;
   %if %upcase(&BIC)=Y %then %do;
    randnmbr1=.;
    fold1=1;
   %end;
   %else %if &foldcnt=n %then %do;
    randnmbr1=.
    fold1=_n_;
   %end;
   %else %do;
    %do ixv=1 %to &xvrepeat;
     randnmbr&ixv=.;
     fold&ixv=.;
    %end;
   %end;
  run;
  %if &foldcnt^=n & %upcase(&BIC)^=Y %then %do;
   proc iml;
    reset noname; * turn off when testing so names come out in prints;
    edit lcvclsin var _all_;
    %do ixv=1 %to &xvrepeat;
     read all var {randnmbr&ixv,fold&ixv};
    %end;
    nobs=nrow(fold1);
    * the following approach for generating the fold assignments
      guarantees that fold assignments for lower xvrepeat values
      agree with the first so many fold assignments for larger
      xvrepeat values
    ;
    %do ixv=1 %to &xvrepeat;
     do iy=1 to nobs;
      * note that even though the same value of &initseed
        is used in each of these assignment statements
        an updated value of the seed is used after the
        first invocation
      ;
      randnmbr&ixv[iy]=uniform(&initseed);
     end;
     fold&ixv=int(randnmbr&ixv*&foldcnt)+1;
    %end;
    %if &foldcnt=1 %then %do;
     %do ixv=1 %to &xvrepeat;
      randordr=rank(randnmbr&ixv);
      ind=(randordr>&holdout*nobs);
      * fold is left equal to 1 on the first &holdout*100% of
        the observations to represent the holdout set and is
        changed to 2 on the rest of the observations to
        represent the training set
      ;
      fold&ixv=fold&ixv+ind;
      replace all var {fold&ixv};
     %end;
    %end;
    %do ixv=1 %to &xvrepeat;
     replace all var {randnmbr&ixv,fold&ixv};
    %end;
   quit;
  %end;
  proc sort;
   by &yvars;
  run;
  data lcvclsin;
   set lcvclsin;
   drop %do ixv=1 %to &xvrepeat;
         randnmbr&ixv
        %end;
   ;
  run;
  proc iml;
   reset noname; * turn off when testing so names come out in prints;
   abort=0;
   edit lcvclsin var _all_;
   read all var {&yvars} into y;
   ny=nrow(y);
   yvarcnt=ncol(y);
   * observations with exactly the same yvars values are
     assigned to the same fold
   ;
   anymiss=0;
   if any(y=.) then do;
    anymiss=1;
    misscont=1;
    do iy=1 to ny while(misscont);
     if all(y[iy,]=.) then do;
      print "some subjects have all their yvars values missing";
      abort=1;
      misscont=0;
     end;
    end;
    %if %quote(&stdizace)^= %then %do;
     print "stdizace not supported with missing yvars values";
     abort=1;
    %end;
    %if %quote(&stdize)=Y %then %do;
     print "stdize=Y not supported with missing yvars values";
     abort=1;
    %end;
    %if &EMLreqst %then %do; 
     print "EML not supported with missing yvars values";
     abort=1;
    %end;
   end;
   continue=1;
   %let ixv=0;
   %do ixv=1 %to &xvrepeat;
    if continue then do;
     read all var {fold&ixv};
     do iy=2 to ny;
      if y[iy,]=y[iy-1,] then
       fold&ixv[iy]=fold&ixv[iy-1];
     end;
     replace all var {fold&ixv};
     foldsize=repeat(0,&foldsize,1);
     %do ifold=1 %to &foldsize;
      foldsize[&ifold]=(fold&ixv=&ifold)[+];
     %end;
     emptyflds=(foldsize=0)[+];
     maxfsize=foldsize[<>];
     %if %upcase(&BIC)^=Y %then %do;
      if maxfsize=ny then do;
       print "all observations in the same fold for xvrepeat=&ixv";
       abort=1;
       continue=0;
      end;
      if &nlst>ny-maxfsize then do;
       print "# of clusters can get too large to compute LCV scores";
       abort=1;
       continue=0;
      end;
     %end;
     %do ifold=1 %to &foldsize;
      call symput("fldsiz&ifold._&ixv",compress(char(foldsize[&ifold])));
     %end;
     * not currently using these macro parameters , but left in for
       for possible later use
     ;
     call symput("empflds&ixv",compress(char(emptyflds)));
     %if &foldcnt=1 & &ixv=1 %then %do;
      if maxfsize=0 then do;
       print "the single fold is empty";
       abort=1;
       continue=0;
      end;
     %end;
    end; * end of continue check;
   %end;
   %if &foldcnt=1 %then %do;
    testcnt=ny-foldsize[1];
   %end;
   %else %do;
    testcnt=ny;
   %end;
   %if %upcase(&keeptst)=Y %then %do;
    if ny>95 then do;
     keepval=1-exp(-cinv(0.95,1)/(2*ny))*&keeplevl/0.02;
    end;
    else do;
     keepval=&keeplevl;
    end;
   %end;
   %else %do;
    keepval=&keeplevl;
   %end;
   call symput("obscnt",compress(char(ny)));
   call symput("yvarcnt",compress(char(yvarcnt)));
   call symput("testcnt",compress(char(testcnt)));
   call symput("anymiss",compress(char(anymiss)));
   call symput("abort",compress(char(abort)));
   call symput("keepval",compress(char(keepval)));
  quit;
  data lcvclsin;
   set lcvclsin;
   %if %quote(&subsetvr)^= %then %do;
    if &subsetvr;
   %end;
   %if %upcase(&stdize)=Y | %upcase(&stdrange)=Y | %quote(&stdizace)^=
   %then %do;
    %do ivar=1 %to &yvarcnt;
     _ystd_&ivar=.;
     %let clusvars=&clusvars _ystd_&ivar;
    %end;
   %end;
  run;
  proc iml;
   reset noname; * turn off when testing so names come out in prints;
   abort=&abort;
   edit lcvclsin var _all_;
   read all var {&yvars} into y;
   ny=nrow(y);
   if ny=0 then do;
    print "no observations to cluster";
    abort=1;
   end;
   else do;
    * handle stdize=Y if necessary;
    %if %upcase(&stdize)=Y %then %do;
     read all var {&clusvars};
     %do ivar=1 %to &yvarcnt;
      _ystd_&ivar=y[,&ivar];
     %end;
     replace all var {&clusvars};
    %end;
    %if %upcase(&stdrange)=Y %then %do;
     read all var {&clusvars};
     miny=y[><,];
     maxy=y[<>,];
     %do ivar=1 %to &yvarcnt;
      if maxy[1,&ivar]>miny[1,&ivar] then do;
       _ystd_&ivar=(y[,&ivar]-miny[1,&ivar])/(maxy[1,&ivar]-miny[1,&ivar]);
      end;
      else do;
       ny=nrow(y);
       _ystd_&ivar=repeat(.,ny,1);
       _ystd_&ivar[loc(y[,&ivar]^=.)]=1; 
           * using 1 as the lim(x/x) as x converges to 0;
      end;
     %end;
     replace all var {&clusvars};
    %end;
   end;
   call symput("abort",compress(char(abort)));
  quit;
  %if ^&abort %then %do;
   data datacopy;
    set lcvclsin;
   run;
   %if %quote(&stdizace)^= %then %do;
    * if the variables already exist in the data set, proc aceclus
      adjusts the names of the output variables rather than writing
      over them
    ;
    data datacopy
     set lcvclsin;
     drop &clusvars;
    run;
    proc aceclus 
         data=datacopy out=datacopy maxiter=100 prefix=_ystd_ noprint
         proportion=&stdizace
    ;
     var &yvars;
    run;
   %end;
   %do ixv=1 %to &xvrepeat;
    %let methcnt=1;
    %let methnext=%qscan(&methlist,&methcnt,%str( ));
    %let did1clus=0;
    %do %while (%quote(&methnext)^=); * beginning of methods loop;
     %let currnosq=;
     %if %upcase(&nonorm)=Y %then %do;
      %let currnorm=nonorm;
     %end;
     %else %do;
      %let currnorm=;
     %end;
     %if %upcase(&notie)=Y %then %do;
      %let currtie=notie;
     %end;
     %else %do;
      %let currtie=;
     %end;
     %let currnn=;
     %let currrad=;
     %let crrpnlty=;
     %let currbeta=;
     %if %qupcase(%quote(&methnext))=AVERNOSQ %then %do;
      %let currmeth=average;
      %let currnosq=nosquare;
     %end;
     %else %if %qupcase(%quote(&methnext))=CENTNOSQ %then %do;
      %let currmeth=centroid;
      %let currnosq=nosquare;
     %end;
     %else %if %qupcase(%quote(&methnext))=MEDNNOSQ %then %do;
      %let currmeth=median;
      %let currnosq=nosquare;
     %end;
     %else %if %qupcase(%quote(&methnext))=WARDNOSQ %then %do;
      %let currmeth=ward;
      %let currnosq=nosquare;
     %end;
     %else %if %length(&methnext)<=4 %then %do;
      %let currmeth=&methnext;
     %end;
     %else %if %qupcase(%substr(%quote(&methnext),1,4))=EML: %then %do;
      %let currmeth=EML;
      %let crrpnlty=p=%substr(&methnext,5);
     %end;
     %else %if %length(&methnext)<=5 %then %do;
      %let currmeth=&methnext;
     %end;
     %else %if %qupcase(%substr(%quote(&methnext),1,5))=FLEX: %then %do;
      %let currmeth=flexible;
      %let currbeta=beta=%substr(&methnext,6);
     %end;
     %else %if %length(&methnext)<=7 %then %do;
      %let currmeth=&methnext;
     %end;
     %else %if %qupcase(%substr(%quote(&methnext),1,7))=DENSNN: %then %do;
      %let currmeth=density;
      %let currnn=k=%substr(&methnext,8);
     %end;
     %else %if %qupcase(%substr(%quote(&methnext),1,7))=2STGNN: %then %do;
      %let currmeth=twostage;
      %let currnn=k=%substr(&methnext,8);
     %end;
     %else %if %qupcase(%substr(%quote(&methnext),1,7))=DENSSS: %then %do;
      %let currmeth=density;
      %let currrad=r=%substr(&methnext,8);
     %end;
     %else %if %qupcase(%substr(%quote(&methnext),1,7))=2STGSS: %then %do;
      %let currmeth=twostage;
      %let currrad=r=%substr(&methnext,8);
     %end;
     %else %do;
      %let currmeth=&methnext;
     %end;
     data temp;
      file log;
      %if &xvrepeat=1 %then %do;
       put "working on method=&methnext";
      %end;
      %else %do;
       put "cross-validation iteration &ixv for method=&methnext";
      %end;
     run;
     %if &ixv=1 %then %do;
      ods exclude all;
      ods results off;
      %if %upcase(&currmeth)^=KMEANS %then %do;
       %if &anymiss %then %do;
        proc distance data=datacopy out=copydist
         %if %quote(&currnosq)= %then %do;
          method=euclid
         %end;
         %else %do;
          method=sqeuclid
         %end;
        ;
         %if %quote(&clusvars)= %then %do;
          var interval (&yvars);
          copy &yvars;
         %end;
         %else %do;
          var interval (&clusvars);
          copy &yvars &clusvars;
         %end;
        run;
        proc cluster 
         data=copydist method=&currmeth &currnn &currrad
          &currnorm &currtie &currnosq &crrpnlty &currbeta
          outtree=copytree 
        ;
         var dist1-dist&datacnt;
         %if %quote(&clusvars)= %then %do;
          copy &yvars;
         %end;
         %else %do;
          copy &yvars &clusvars;
         %end;
        run;
       %end;
       %else %do;
        proc cluster 
         data=datacopy method=&currmeth &currnn &currrad
         &currnorm &currtie &currnosq &crrpnlty &currbeta
         %if %upcase(&stdize)=Y %then %do;
          standard 
         %end;
         outtree=copytree 
        ;
         %if %quote(&clusvars)= %then %do;
          var &yvars;
          copy &yvars;
         %end;
         %else %do;
          var &clusvars;
          copy &yvars &clusvars;
         %end;
        run;
       %end; 
      %end;
      ods results on;
      ods exclude none;
     %end;
     %let nstrt=%eval(&nfst+&did1clus);
     %do inc=&nstrt %to &nlst;
      %if &inc=1 %then %do;
       %let did1clus=1;
      %end;
      %let evrzro&inc=0;
      %if &ixv=1 %then %do;
       ods exclude all;
       ods results off;
       %if %upcase(&currmeth)^=KMEANS %then %do;
        proc tree  
         data=copytree out=copyclus nclusters=&inc noprint
        ;
        %if %quote(&clusvars)= %then %do;
         copy &yvars;
        %end;
        %else %do;
         copy &clusvars &yvars;
        %end;
        run;
       %end;
       %else %do;
        %if %upcase(&stdize)=Y %then %do;
         * not currently used;
         proc standard 
          data=datacopy out=datacopy mean=0 std=1 noprint
         ;
          var &clusvars;
         run;
        %end;
        proc fastclus 
         data=datacopy maxclusters=&inc noprint out=copyclus
        ;
         %if %quote(&clusvars)= %then %do;
          var &yvars;
         %end;
         %else %do;
          var &clusvars;
         %end;
        run; 
       %end;
       ods results on;
       ods exclude none;
       proc iml;
        reset noname; * turn off when testing so names come out in prints;
        edit copyclus var _all_;
        read all var _all_;
        ind=(cluster=1);
        mincsize=(cluster[loc(ind)])[+];
        %do iclstr=2 %to &inc;
         ind=(cluster=&iclstr);
         currsize=ind[+];
         if currsize<mincsize then
          mincsize=currsize;
        %end;
        call symput("mincsize",compress(char(mincsize)));
       quit;
      %end;
      data lcvscr&inc;
       length method $ 12;
       xvindex=&ixv;
       %if &inc=1 %then %do;
        method="--";
       %end;
       %else %do;
        method="%upcase(&methnext)";
       %end;
       methord=&methcnt;
       nonorm="%upcase(&nonorm)";
       nclstrs=&inc;
       lcvvalue=0;
       %if &ixv=1 %then %do;
        mincsize=&mincsize;
       %end;
       %else %do;
        mincsize=.;
       %end;
       label xvindex="Cross-Validation Index"
             method="Method"
             methord="Method Order"
             nonorm="Nonorm On?"
             nclstrs="# of Clusters"
             lcvvalue="LCV Score"
             mincsize="Minimum Cluster Size"
             ;
       %if %upcase(&BIC)=Y %then %do;
        bicvalue=0;
        label bicvalue="BIC Score";
       %end;
      run;
     %end;
     %let noclstrs=0;
     %do ifold=1 %to &foldsize;
      %if %upcase(&testcalc)=Y %then %do;
       %let foldname=fold&ifold._&ixv;
      %end;
      %else %do;
       %let foldname=fold;
      %end;
      data &foldname;
       set lcvclsin;
       if fold&ixv=&ifold;
      run;
      %if &&fldsiz&ifold._&ixv>0 & ^&&noclstrs %then %do;
       data complmnt;
        set lcvclsin;
        %if %upcase(&BIC)^=Y %then %do;
         if fold&ixv^=&ifold;
        %end;
       run;
       proc iml;
        reset noname; * turn off when testing so names come out in prints;
        edit complmnt var _all_;
        read all var {&yvars} into y;
        ny=nrow(y);
        call symput("compcnt",compress(char(ny)));
       quit;
       %if %upcase(&stdrange)=Y %then %do;
        proc iml;
         reset noname; * turn off when testing so names come out in prints;
         edit complmnt var _all_;
         read all var {&yvars} into y;
         read all var {&clusvars};
         miny=y[><,];
         maxy=y[<>,];
         %do ivar=1 %to &yvarcnt; 
          if maxy[1,&ivar]>miny[1,&ivar] then do;
           _ystd_&ivar=(y[,&ivar]-miny[1,&ivar])
                           /(maxy[1,&ivar]-miny[1,&ivar]);
          end;
          else do;
           ny=nrow(y);
           _ystd_&ivar=repeat(.,ny,1);
           _ystd_&ivar[loc(y[,&ivar]^=.)]=1; 
                 * using 1 as the lim(x/x) as x converges to 0;
          end;
         %end;
         replace all var {&clusvars};
        quit;
       %end;
       %if %quote(&stdizace)^= %then %do;
        * if the variables already exist in the data set, proc aceclus
          adjusts the names of the output variables rather than writing
          over them
        ;
        data complmnt;
         set complmnt;
         drop &clusvars;
        run;
        proc aceclus 
            data=complmnt out=complmnt maxiter=100 prefix=_ystd_ noprint
            proportion=&stdizace
            ;
         var &yvars;
        run;
       %end;
       ods exclude all;
       ods results off;
       %if %upcase(&currmeth)^=KMEANS %then %do;
        %if &anymiss %then %do;
         proc distance data=complmnt out=compdist
          %if %quote(&currnosq)= %then %do;
           method=euclid
          %end;
          %else %do;
           method=sqeuclid
          %end;
         ;
          %if %quote(&clusvars)= %then %do;
           var interval (&yvars);
           copy &yvars;
          %end;
          %else %do;
           var interval (&clusvars);
           copy &yvars &clusvars;
          %end;
         run;
         proc cluster 
          data=compdist method=&currmeth &currnn &currrad
           &currnorm &currtie &currnosq &crrpnlty &currbeta
           %if %upcase(&testcalc)=Y %then %do;
            outtree=tree&ifold._&ixv 
           %end;
           %else %do;
            outtree=tree 
           %end;
         ;
          var dist1-dist&compcnt;
          %if %quote(&clusvars)= %then %do;
           copy &yvars;
          %end;
         %else %do;
           copy &yvars &clusvars;
          %end;
         run;
        %end;
        %else %do;
         proc cluster 
          data=complmnt method=&currmeth &currnn &currrad
          &currnorm &currtie &currnosq &crrpnlty &currbeta
          %if %upcase(&stdize)=Y %then %do;
           standard 
          %end;
          %if %upcase(&testcalc)=Y %then %do;
           outtree=tree&ifold._&ixv 
          %end;
          %else %do;
           outtree=tree 
          %end;
         ;
          %if %quote(&clusvars)= %then %do;
           var &yvars;
           copy &yvars;
          %end;
          %else %do;
           var &clusvars;
           copy &yvars &clusvars;
          %end;
         run;
        %end; 
       %end;
       ods results on;
       ods exclude none;
       %do inc=&nstrt %to &nlst; * beginning of clusters loop;
        %let everzero=&&evrzro&inc;
        %if ^&everzero & ^&noclstrs %then %do;
         ods exclude all;
         ods results off;
         %if %upcase(&testcalc)=Y %then %do;
          %let treename=tree&ifold._&ixv;
          %let cmpclsnm=cmpcls&ifold._&ixv; 
         %end;
         %else %do;
          %let treename=tree;
          %let cmpclsnm=compclus; 
         %end;
         %if %upcase(&currmeth)^=KMEANS %then %do;
          proc tree  
           data=&treename out=&cmpclsnm nclusters=&inc noprint
          ;
          %if %quote(&clusvars)= %then %do;
           copy &yvars;
          %end;
          %else %do;
           copy &clusvars &yvars;
          %end;
          run;
         %end;
         %else %do;
          %if %upcase(&stdize)=Y %then %do;
           * not currently used;
           proc standard 
            data=complmnt out=complmnt mean=0 std=1 noprint
           ;
            var &clusvars;
           run;
          %end;
          proc fastclus 
           data=complmnt maxclusters=&inc
           noprint out=&cmpclsnm
          ;
           %if %quote(&clusvars)= %then %do;
            var &yvars;
           %end;
           %else %do;
            var &clusvars;
           %end;
          run; 
         %end;
         proc contents data=&cmpclsnm out=ccobscnt noprint;
         run;
         ods results on;
         ods exclude none;
         data ccobscnt;
          set ccobscnt;
          if _n_=1;
          call symput("ccobscnt",nobs);
         run;
         %if &ccobscnt>0 %then %do;
          proc sort data=&cmpclsnm;
           by cluster;
          run;
         %end;
         proc iml symsize=4000 worksize=4000;
          %if %upcase(&testcalc)^=Y %then %do;
           reset noname; 
          %end;
          nocalc=0;
          everzero=0;
          edit &foldname var _all_;
          read all var {&yvars} into fy;
          fycnt=ncol(fy);
          fn=nrow(fy);
          %if %upcase(&testcalc)=Y %then %do;
           print fycnt fn;
          %end;
          %if %quote(&idvar)^= %then %do;
           read all var {&idvar} into fid;
          %end;
          %if &ccobscnt=0 %then %do;
           print "empty cluster solution method=&methnext";
           nocalc=1;
           %let noclstrs=1;
          %end;
          %else %do;
           edit &cmpclsnm var _all_;
           read all var {cluster};
           read all var {&yvars} into cy;
           cycnt=ncol(cy); * cycnt and fycnt will be equal;
           cn=nrow(cy);
           %if %upcase(&testcalc)=Y %then %do;
            print cycnt cn;
           %end;
           cluscnt=repeat(0,&inc,1);
           cprop=repeat(0,&inc,1);
           cmean=repeat(0,&inc,cycnt);
           pi=3.14159265358979;
          %end;
          cyind=(cy^=.);
          %if ^&noclstrs %then %do;
           * load the parameter estimates computed from the current fold
             complement for the mixture of &inc groups, multivariate
             normally distributed with possibly different mean vectors
             loaded into the variable cmean, possibly different
             probabilities for belonging to a group loaded into cprop,
             and possibly different variance vectors and correlation
             matrices loaded into cvar and ccorr&iclstr  

             variances are estimated using the usual average sums of
             squares approach summing over sets of observations and
             variables determined by the yvarnces and cvarnces settings 

             given the variance estimate that is used, the associated
             estimate of the correlation matrix (when the correlations
             are not treated as being constant) will maximize the 
             likelihood (the argument is similar to the one in Johnson &
             Wichern, Multivariate Statistics, Prentice Hall, 3rd ed.,
             1992 for the case of an unstructured covariance matrix with
             1 cluster), but the variance estimates (and the constant
             correlation estimate) need not be maximum likelihood
             estimates 

             when both yvarnces and ycorrs are set to DIFF and cvarnces
             and ccorrs are set either both to SAME or both to DIFF, 
             variance and correlation estimate maximize the likelihood
             (see Symons, 1981 referenced in the SAS Users Guide)
             at least when all the variance estimates are nonzero and
             all estimated correlation matrices are non-singular, but
             this may no longer hold for the other degenerate cases due
             to their special handling 

             even if nondegenerate estimates are possible for a cluster
             with degenerate standard covariance estimates through
             combining the data in that cluster with data from other
             clusters, this is not done to reduce the chance of 
             generating degenerate clusters in the selected cluster
             solution
           ;
           csumsqs=repeat(0,&inc,cycnt);
           csumcnt=repeat(0,&inc,cycnt);
           cvar=repeat(0,&inc,cycnt);
           do iclstr=1 to &inc;
            ind=(cluster=iclstr);
            cluscnt[iclstr]=ind[+];
            cprop[iclstr]=cluscnt[iclstr]/cn;
            do ivar=1 to cycnt;
             ind2=ind#cyind[,ivar];
             if ind2[+]>0 then do;
              cyhold=cy[loc(ind2),ivar];
              cmean[iclstr,ivar]=cyhold[+]/ind2[+];
             end;
            end;
            do ivar=1 to cycnt;
             ind2=ind#cyind[,ivar];
             if ind2[+]>0 then do;
              cyhold=cy[loc(ind2),ivar];
              diffy=cyhold-cmean[iclstr,ivar];
              csumsqs[iclstr,ivar]=(diffy#diffy)[+];
             end;
             csumcnt[iclstr,ivar]=ind2[+];
            end;
           end;
           pparmcnt=&inc-1; * # distinct cluster proportions;
           mparmcnt=cycnt*&inc; * # of distinct means;
           %if %upcase(&testcalc)=Y %then %do;
            print "before", csumsqs;
           %end;
           %if %upcase(&yvarnces)=SAME & %upcase(&cvarnces)=SAME %then %do;
            vparmcnt=1; * # distinct variances;
            ind=(csumcnt>0);
            cvarhold=csumsqs[+];
            cvarcnt=ind[+];
            if cvarcnt>0 then do;
             cvar[loc(ind)]=cvarhold/cvarcnt;
            end;
           %end;
           %else %if %upcase(&yvarnces)=SAME & %upcase(&cvarnces)=DIFF 
           %then %do;
            vparmcnt=&inc; * # distinct variances;
            %do iclstr=1 %to &inc;
             ind=(csumcnt[&iclstr,]>0);
             cvarhold=csumsqs[&iclstr,+];
             if ind[+]>0 then do;
              cvar[&iclstr,loc(ind)]=cvarhold/ind[+];
             end;
            %end;
           %end;
           %else %if %upcase(&yvarnces)=DIFF & %upcase(&cvarnces)=SAME 
           %then %do;
            vparmcnt=cycnt; * # distinct variances;
            do ivar=1 to cycnt;
             ind=(csumcnt[,ivar]>0);
             cvarcnt=csumcnt[+,ivar];
             cvarhold=csumsqs[+,ivar];
             if cvarcnt>0 then do;
              cvar[loc(ind),ivar]=cvarhold/cvarcnt;
             end;
            end;
           %end;
           %else %do; * the both DIFF case;
            vparmcnt=&inc*cycnt; * # distinct variances;
            do iclstr=1 to &inc;
             do ivar=1 to cycnt;
              if csumcnt[iclstr,ivar]>0 then do;
               cvar[iclstr,ivar]=csumsqs[iclstr,ivar]/csumcnt[iclstr,ivar];
              end;
             end;
            end;
           %end;
           cstd=cvar##0.5;
           nearzero=(cstd<&near0std);
           if nearzero[+]>0 then do;
            cstd[loc(nearzero)]=&near0std;
           end;
           prodcstd=repeat(1,&inc,1);
           overcstd=repeat(0,&inc,cycnt);
           do iclstr=1 to &inc;
            do ivar=1 to cycnt;
              prodcstd[iclstr]=prodcstd[iclstr]*cstd[iclstr,ivar];
              overcstd[iclstr,ivar]=1/cstd[iclstr,ivar];
            end;
           end;
           %if %upcase(&ycorrs)=ZERO %then %do;
            cparmcnt=0; * number of distinct correlations;
            %do iclstr=1 %to &inc;
              ccorr&iclstr=i(cycnt);
            %end;
           %end;
           %else %do;
            %do iclstr=1 %to &inc;
             ccorr0&iclstr=repeat(0,cycnt,cycnt);
             ccnt&iclstr=repeat(0,cycnt,cycnt);
             ind=(cluster=&iclstr);
             cyhold=cy[loc(ind),];
             do ivar1=1 to cycnt-1;
              do ivar2=ivar1+1 to cycnt;
               ind2=(cyhold[,ivar1]^=.)#(cyhold[,ivar2]^=.);
               * print ivar1 ivar2, ind2 cyhold, (ind2[+]);
               if ind2[+]>0 then do;
                diff1=(cyhold[loc(ind2),ivar1]
                           -cmean[&iclstr,ivar1]);
                zdiff1=diff1*overcstd[&iclstr,ivar1];
                diff2=(cyhold[loc(ind2),ivar2]
                           -cmean[&iclstr,ivar2]);
                zdiff2=diff2*overcstd[&iclstr,ivar2];
                ccorr0&iclstr[ivar1,ivar2]=(zdiff1#zdiff2)[+];
               end;
               ccnt&iclstr[ivar1,ivar2]=ind2[+];
              end;
             end;
             %if %upcase(&testcalc)=Y %then %do;
              print "before", ccorr0&iclstr;
             %end;
            %end;
            %if %upcase(&ycorrs)=SAME & %upcase(&ccorrs)=SAME %then %do;
             cparmcnt=1; * number of distinct correlations;
             ccorrhld=0;
             ccnthold=0;
             %do iclstr=1 %to &inc;
              ccorrhld=ccorrhld+ccorr0&iclstr[+];
              ccnthold=ccnthold+ccnt&iclstr[+];
             %end;
             if ccnthold>0 then do;
              ccorrhld=ccorrhld/ccnthold;
             end;
             else do;
              ccorrhld=0;
             end;
             %do iclstr=1 %to &inc;
              ccorr&iclstr=i(cycnt)+ccorrhld*(j(cycnt,cycnt)-diag(ind));
             %end;
            %end;
            %else %if %upcase(&ycorrs)=SAME & %upcase(&ccorrs)=DIFF 
            %then %do;
             cparmcnt=&inc; * number of distinct correlations;
             %do iclstr=1 %to &inc;
              ccorrhld=ccorr0&iclstr[+];
              ccnthold=ccnt&iclstr[+];
              if ccnthold>0 then do;
               ccorrhld=ccorrhld/ccnthold;
              end;
              else do;
               ccorrhld=0;
              end;
              ccorr&iclstr=i(cycnt)+ccorrhld*(j(cycnt,cycnt)-diag(ind));
             %end;
            %end;
            %else %if %upcase(&ycorrs)=DIFF & %upcase(&ccorrs)=SAME 
            %then %do;
             cparmcnt=cycnt*(cycnt-1)/2; * number of distinct correlations;
             ccorrhld=repeat(0,cycnt,cycnt);
             ccnthold=repeat(0,cycnt,cycnt);
             %do iclstr=1 %to &inc;
              ccorrhld=ccorrhld+ccorr0&iclstr;
              ccnthold=ccnthold+ccnt&iclstr;
             %end;
             ind=(ccnthold^=0);
             if ind[+]>0 then do;
              ccorrhld[loc(ind)]=ccorrhld[loc(ind)]/ccnthold[loc(ind)];
             end;
             %do iclstr=1 %to &inc;
              jind=j(cycnt,cycnt);
              ccorr&iclstr=ccorrhld#jind+i(cycnt)+(ccorrhld#jind)`;
             %end;
            %end;
            %else %do; * the both DIFF case;
             cparmcnt=&inc*cycnt*(cycnt-1)/2;
                * number of distinct correlations;
             %do iclstr=1 %to &inc;
              ccorrhld=repeat(0,cycnt,cycnt);
              ind=(ccnt&iclstr^=0);
              if ind[+]>0 then do;
               ccorrhld[loc(ind)]=ccorr0&iclstr[loc(ind)]/ccnt&iclstr[loc(ind)];
              end;
              jind=j(cycnt,cycnt);
              ccorr&iclstr=ccorrhld#jind+i(cycnt)+(ccorrhld#jind)`;
             %end;
            %end;
           %end;
           parmcnt=pparmcnt+mparmcnt+vparmcnt+cparmcnt;
           %if %upcase(&testcalc)=Y %then %do;
            print pparmcnt mparmcnt vparmcnt cparmcnt parmcnt;
           %end; 
           * it is possible in some cases, for example, when
             cvarnces=SAME and CCORRS=DIFF for correlation
             estimates to be distinctly less than -1 or
             distinctly > +1, but such cases will generate
             zero likelihood scores and so tend to not be selected
 
             it is also possible to get degenerate cases of exactly
             +1 or -1 which means associated pairs of y variables
             are treated as having values on an exact straight line
             these cases will also generate zero likelihood scores
             even for observations in the fold whose values for the 
             associated coordinates are on those lines
           ;
           %do iclstr=1 %to &inc;
            unitcorr&iclstr=0;
            ind=(ccorr&iclstr#(j(cycnt)-i(cycnt))<-1+1e-5);
            if ind[+]>0 then do;
             unitcorr&iclstr=1;
            end;
            ind=(ccorr&iclstr#(j(cycnt)-i(cycnt))>1-1e-5);
            if ind[+]>0 then do;
             unitcorr&iclstr=1;
            end;
           %end;
           %do iclstr=1 %to &inc;
            ccov&iclstr=diag(cstd[&iclstr,])*ccorr&iclstr*diag(cstd[&iclstr,]);
           %end;
           %if %upcase(&testcalc)=Y %then %do;
            print cluscnt cprop cmean cvar cstd prodcstd overcstd;
            %do iclstr=1 %to &inc;
             print unitcorr&iclstr ccorr&iclstr;
             print ccov&iclstr;  
            %end;
           %end;
           detval=repeat(.,&inc,1);
           %do iclstr=1 %to &inc;
            eignvals=eigval(ccorr&iclstr);
            nearzero=(eignvals<&near0eig); 
            if nearzero[+]>0 then do;
             eignvecs=eigvec(ccorr&iclstr);
             adjeigns=eignvals;
             adjeigns[loc(nearzero)]=&near0eig;
             ccorr&iclstr=eignvecs*diag(adjeigns)*eignvecs`;
             %if %upcase(&testcalc)=Y %then %do;
              print eignvals adjeigns "iclstr=&iclstr";
             %end;
             eignvals=adjeigns;
            end;
            ldetcrr=(log(eignvals))[+];
            detval[&iclstr]=exp(-ldetcrr/2);
            invccorr&iclstr=ginv(ccorr&iclstr);
            invccov&iclstr=
              diag(overcstd[&iclstr,])*invccorr&iclstr*diag(overcstd[&iclstr,]);
            invccovb&iclstr=ginv(ccov&iclstr);
            %if %upcase(&testcalc)=Y %then %do;
             print invccorr&iclstr;
             print invccov&iclstr;
             print invccovb&iclstr;
            %end;
           %end;
           %if %upcase(&testcalc)=Y %then %do;
            print detval;
           %end;
           * calculate contribution to LCV score for fold;
            clusdens=repeat(0,&inc,1);
            clusll=0;
            fyind=(fy^=.);
            do if=1 to fn;
             %do iclstr=1 %to &inc;
              diffy=(fy[if,loc(fyind[if,])]
                         -cmean[&iclstr,loc(fyind[if,])]);
              zdiffy=repeat(0,1,cycnt);
              zdiffy[1,loc(fyind[if,])]=
                      diffy#overcstd[&iclstr,loc(fyind[if,])];

              lhold=log(detval[&iclstr]/prodcstd[&iclstr]);
              %if %upcase(&testcalc)=Y %then %do;
               normval=-zdiffy*invccorr&iclstr*zdiffy`/2;
               hold1=zdiffy*invccorr&iclstr;
               print zdiffy hold1;
               print normval lhold "iclstr=&iclstr" if;
               print (exp(-zdiffy*invccorr&iclstr*zdiffy`/2+lhold))
                     (-zdiffy*invccorr&iclstr*zdiffy`/2+lhold);
              %end;
              clusdens[&iclstr]=exp(-zdiffy*invccorr&iclstr*zdiffy`/2+lhold);
              * zero density values increased to a small nonzero amount;
              clusdens[&iclstr]=max(clusdens[&iclstr],&mindens);
             %end;
             %if %upcase(&scretype)=EXPECTED %then %do;
              wgtddens=cprop#clusdens;
              cluswgts=wgtddens/wgtddens[+];
              %if %upcase(&testcalc)=Y %then %do;
               print cprop clusdens wgtddens cluswgts;
              %end;
              ind=(cluswgts>0);
              densterm=(cluswgts[loc(ind)]#log(wgtddens[loc(ind)]))[+];
             %end;
             %else %if %upcase(&scretype)=MIXTURE %then %do;
              densterm=log((cprop#clusdens)[+]);
             %end;
             %else %do; * so scretype is PREDICTD;
              densterm=log((cprop#clusdens)[<>]);
              * the following tended to favor singleton clusters
                because it ignores cprop and so is not recommnended
              ;
              * densterm=log(clusdens[<>]);
             %end;
             clusll=clusll+densterm;
             %if %upcase(&testcalc)=Y %then %do;
              print if everzero densterm clusll clusdens;
             %end;
            end; 
            clusll=clusll-fn*fycnt/2*log(2*pi); 
            %if %upcase(&testcalc)=Y %then %do;
             print everzero clusll "ifold" &ifold;
            %end; 
            %if %upcase(&BIC)=Y %then %do;
             clusll=clusll-parmcnt*log(fn)/2;
             %if %upcase(&testcalc)=Y %then %do;
              print "BIC" clusll parmcnt fn (log(fn)/2);
             %end; 
            %end;
            * end of fold contribution computation;
           * end of unstructured multivariate normal scoring;
          %end;
          edit lcvscr&inc var _all_;
          read all var _all_;
          %if %upcase(&testcalc)=Y %then %do;
           print "before" lcvvalue;
          %end;
          if ^nocalc then do;
           if ^everzero then do;
            %if %upcase(&BIC)=Y %then %do;
             bicvalue=-2*clusll;
             %if %upcase(&testcalc)=Y %then %do;
              print "BIC" bicvalue;
             %end;
             lcvvalue=lcvvalue+clusll/(fycnt*fn);
            %end;
            %else %if &foldsize>1 %then %do;
             lcvvalue=lcvvalue+clusll/(fycnt*(fn+cn));
            %end;
            %else %do;
             lcvvalue=lcvvalue+clusll/(fycnt*fn);
            %end;
           end;
           else do;
            lcvvalue=0;
           end;
          end;
          else do;
           lcvvalue=.;
          end;
          %if %upcase(&testcalc)=Y %then %do;
           print "after" lcvvalue;
          %end;
          replace all var {lcvvalue
                           %if %upcase(&BIC)=Y %then %do;
                            ,bicvalue
                           %end;
                          };
          call symput("evrzro&inc",compress(char(everzero)));
         quit;
         * end of not ever zero nor no clusters handling;
        %end;
        %else %if &noclstrs %then %do;
         proc iml;
          edit lcvscr&inc var _all_;
          read all var _all_;
          %if %upcase(&testcalc)=Y %then %do;
           print "before" lcvvalue;
          %end;
          lcvvalue=.;
          %if %upcase(&testcalc)=Y %then %do;
           print "after" lcvvalue;
          %end;
          replace all var {lcvvalue};
         quit;
        %end;
        %if %upcase(&testcalc)^=Y %then %do;
         * if not deleted, it will not be replaced if ever empty;
         ods exclude all;
         ods results off;
         proc datasets library=work;
          delete &cmpclsnm;
         run;
         ods results on;
         ods exclude none;
        %end; 
       %end; * end of # clusters loop;
      %end; * end of nonempty fold handling;
     %end; * end of # folds loop;
     %do inc=&nstrt %to &nlst;
      %let everzero=&&evrzro&inc;
      %if ^&everzero %then %do;
       %if %upcase(&testcalc)=Y %then %do;
        proc print data=lcvscr&inc; run;
       %end;
       data lcvscr&inc;
        set lcvscr&inc;
        lcvvalue=exp(lcvvalue);
       run;
      %end;
     %end;
     %if &methcnt=1 & &ixv=1 %then %do;
      data lcvscres;
       set lcvscr&nfst;
      run;
      %do inc=%eval(&nfst+1) %to &nlst;
       data lcvscres;
        set lcvscres lcvscr&inc;
       run;
      %end;
     %end;
     %else %do; 
      %do inc=&nstrt %to &nlst;
       data lcvscres;
        set lcvscres lcvscr&inc;
       run;
      %end;
     %end;
     %if %upcase(&testcalc)=Y %then %do;
      proc print data=lcvscres; run;
     %end;
     %let methcnt=%eval(&methcnt+1);
     %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
    %end; * end of methods loop;
    %let methcnt=%eval(&methcnt-1);
   %end; * end of xvrepeat loop;
  %end;
 %end;
 %if ^&abort %then %do;
  %if %upcase(&BIC)=Y %then %do;
   %let title1=Best Bayesian Information Criterion;
  %end;
  %else %if &foldcnt=n %then %do;
   %let title1=Leave-One-Out Likelihood Cross-Validation;
  %end;
  %else %if &foldcnt=1 %then %do;
   %let title1=Holdout Likelihood Cross-Validation;
  %end;
  %else %do;
   %let title1=&foldcnt-Fold Likelihood Cross-Validation;
  %end;
  %if %upcase(&BIC)^=Y & &foldcnt^=n %then %do;
   %if &foldcnt=1 %then %do;
    title1 "&title1 (with &testcnt training observations)";
   %end;
   title1 "&title1";
  %end;
  %else %do;
    title1 "&title1";
  %end;
  %if &xvrepeat=1 %then %do;
   %let title2=with 1 Repetition;
  %end;
  %else %do;
   %let title2=with &xvrepeat Repetitions;
  %end;
  title2 "&title2 for Cluster Analysis of Variables"; 
  %if &yprefix^= %then %do;
   %let title3=&yprefix.&yfst to &yprefix.&ylst by Increments of &yby;
  %end;
  %else %do;
   %let yvarscmp=%cmpres(&yvars);
   %if %length(&yvarscmp)>70 %then %do;
    %let list=%substr(&yvarscmp,1,70) ...;
   %end;
   %else %do;
    %let list=&yvarscmp;
   %end;
   %let title3=%upcase(&list);
  %end;
  %let title4=from the ;
  %if &subsetvr^= %then %do;
   %let title4=&title3 %upcase(&subsetvr) Subset of the;
  %end;
  title3 "&title3";
  title4 "&title4 %upcase(&datain) Data Set";
  title5 
  "Using yvarnces=&yvarnces, ycorrs=&ycorrs, cvarnces=&cvarnces, ccorrs=&ccorrs";
  proc iml;
   reset noname; * turn off when testing so names come out in prints;
   edit lcvscres var _all_;
   read all var _all_;
   nobs=nrow(xvindex);
   %let methcnt=1;
   %let methnext=%qscan(&methlist,&methcnt,%str( ));
   %let did1clus=0;
   %do %while (%quote(&methnext)^=); * beginning of methods loop;
    %let nstrt=%eval(&nfst+&did1clus);
    %do inc=&nstrt %to &nlst;
     %if &inc=1 %then %do;
      %let did1clus=1;
      ind1=(method="--" & nclstrs=&inc);
     %end;
     %else %do;
      ind1=(method="&methnext" & nclstrs=&inc);
     %end;
     currmin=(mincsize[loc(ind1)])[<>];
     mincsize[loc(ind1)]=currmin;
      print "&methnext" &inc currmin;
    %end; * end of # of clusters loop;
    %let methcnt=%eval(&methcnt+1);
    %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
   %end; * end of methods loop;
   %let methcnt=%eval(&methcnt-1);
   replace all var {mincsize};
  quit;
  data lcvscre1;
   set lcvscres;
   if mincsize>=&minsize & mincsize>=&minprop*&datacnt;
  run;
  proc iml;
   reset noname; * turn off when testing so names come out in prints;
   edit lcvscre1 var _all_;
   read all var _all_;
   nobs=nrow(xvindex);
   sepdecrs=repeat(0,nobs,1);
   %do ixv=1 %to &xvrepeat;
    ind=(xvindex=&ixv);
    maxscore=(lcvvalue[loc(ind)])[<>];
    if maxscore>0 then do;
     sepdecrs[loc(ind)]=(maxscore-lcvvalue[loc(ind)])/maxscore;
    end;
    else do;
     sepdecrs[loc(ind)]=.;
    end;
   %end;
   conf01=repeat(0,nobs,1);
   conf02=repeat(0,nobs,1);
   conf05=repeat(0,nobs,1);
   maxdecrs=repeat(0,nobs,1);
   avedecrs=repeat(0,nobs,1);
   lcvave=repeat(0,nobs,1);
   lcvtrave=repeat(0,nobs,1);
   %let methcnt=1;
   %let methnext=%qscan(&methlist,&methcnt,%str( ));
   %let did1clus=0;
   %do %while (%quote(&methnext)^=); * beginning of methods loop;
    %let nstrt=%eval(&nfst+&did1clus);
    %do inc=&nstrt %to &nlst;
     %if &inc=1 %then %do;
      %let did1clus=1;
      ind1=(method="--" & nclstrs=&inc);
     %end;
     %else %do;
      ind1=(method="&methnext" & nclstrs=&inc);
     %end;
     ind2=(ind1 & sepdecrs^=.);
     if ind2[+]>0 then do;
      confhld1=((sepdecrs[loc(ind2)]<=0.01)[+])/ind1[+];
      confhld2=((sepdecrs[loc(ind2)]<=0.02)[+])/ind1[+];
      confhld5=((sepdecrs[loc(ind2)]<=0.05)[+])/ind1[+];
      maxhold=(sepdecrs[loc(ind2)])[<>];
      ave1hold=(sepdecrs[loc(ind2)])[:];
      ave2hold=(lcvvalue[loc(ind2)])[:];
      %if &xvrepeat>2 %then %do;
       ave3hold=(lcvvalue[loc(ind2)])[+];
       ave3hold=ave3hold-lcvvalue[loc(ind2)][><];
       ave3hold=ave3hold-lcvvalue[loc(ind2)][<>];
       ave3hold=ave3hold/(&xvrepeat-2);
      %end;
      %else %do;
       ave3hold=.;
      %end;
     end;
     else do;
      confhld1=.;
      confhld2=.;
      confhld5=.;
      maxhold=.;
      ave1hold=.;
      ave2hold=.;
      ave3hold=.;
     end;
     if ind1[+]>0 then do;
      conf01[loc(ind1)]=confhld1;
      conf02[loc(ind1)]=confhld2;
      conf05[loc(ind1)]=confhld5;
      maxdecrs[loc(ind1)]=maxhold;
      avedecrs[loc(ind1)]=ave1hold;
      lcvave[loc(ind1)]=ave2hold;
      lcvtrave[loc(ind1)]=ave3hold;
     end;
    %end; * end of # of clusters loop;
    %let methcnt=%eval(&methcnt+1);
    %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
   %end; * end of methods loop;
   %let methcnt=%eval(&methcnt-1);
   comdecrs=repeat(0,nobs,1);
   maxscore=lcvave[<>];
   if maxscore>0 then do;
    comdecrs=(maxscore-lcvave)/maxscore;
   end;
   else do;
    comdecrs=.;
   end;
   create lcvscre2 
      var {xvindex method methord nonorm nclstrs lcvvalue
           sepdecrs conf01 conf02 conf05 maxdecrs avedecrs
           lcvave lcvtrave comdecrs mincsize
           %if %upcase(&BIC)=Y %then %do;
            bicvalue
           %end;
          };
   append;
  quit;
  data lcvscre1;
   set lcvscre2;
   label xvindex="Cross-Validation Index"
         method="Method"
         methord="Method Order"
         nclstrs="# of Clusters"
         nonorm="Nonorm On?"
         lcvvalue="LCV Score"
         mincsize="Minumum Cluster Size"
         sepdecrs="Proportional Decrease from Best Score"
         conf01="% Time Decrease <= 0.01"
         conf02="% Time Decrease <= 0.02"
         conf05="% Time Decrease <= 0.05"
         maxdecrs="Worst Case Decrease"
         avedecrs="Average Decrease"
         lcvave="LCV Average"
         lcvtrave="Trimmed LCV Average"
         comdecrs="Proportional Decrease from Best Average"
         %if %upcase(&BIC)=Y %then %do;
          bicvalue="Bayesian Information Criterion Score"
         %end;
         ;
   %if &scorefmt^= %then %do;
    format lcvvalue lcvave 7.&scorefmt;
   %end;
   %if %upcase(&BIC)=Y %then %do;
    format bicvalue 9.6;
   %end;
   %if &decrsfmt^= %then %do;
    format sepdecrs maxdecrs avedecrs comdecrs 7.&decrsfmt;
   %end;
   format conf01 conf02 conf05 percent7.1;
  run;
  data bestscrs;
   set lcvscre1;
   if xvindex=1;
   if comdecrs^=. then do;
    if comdecrs<=&keepval & lcvave^=.;
    *if avedecrs<=&keepval & lcvave^=.;
    *if maxdecrs<=&keepval & lcvave^=.; * possibly empty!;
   end;
  run;
  proc sort;
   %if %upcase(&mlistord)=Y %then %do;
    by comdecrs nclstrs methord;
   %end;
   %else %do;
    by comdecrs nclstrs method;
   %end;
  run;
  %if  %upcase(&printall)=Y & %upcase(&noprint)^=Y %then %do;
   proc print label noobs data=lcvscre1;
    %if &xvrepeat=1 %then %do;
     var method nonorm nclstrs lcvvalue sepdecrs mincsize
         %if %upcase(&BIC)=Y %then %do;
          bicvalue
         %end;
     ;
    %end;
    %else %do;
     var xvindex method nonorm nclstrs lcvvalue sepdecrs mincsize;
    %end;
   run;
  %end;
  data optimal;
   set bestscrs;
   if _n_=1;
   call symput("optnc",nclstrs);
   call symput("optmeth",method);
  run;
  %if %upcase(&mlistord)=Y %then %do;
   %let comment=Ordered by Score, # of Clusters, and Method Listed Order;
  %end;
  %else %do;
   %let comment=Ordered by Score, # of Clusters, and Method Name;
  %end;
  title6 "Clustering Methods within Tolerance &keepval";
  title7 "&comment";
  %if %upcase(&noprint)^=Y %then %do;
    %if &xvrepeat=1 %then %do;
     proc print label noobs data=bestscrs;
      var method nonorm nclstrs lcvvalue sepdecrs mincsize
          %if %upcase(&BIC)=Y %then %do;
           bicvalue
          %end;
      ;
     run;
    %end;
    %else %do;
     proc print label noobs data=bestscrs;
      var method nclstrs nonorm conf01 conf02 lcvave comdecrs mincsize;
     run;
     proc print label noobs data=bestscrs;
      var method nclstrs avedecrs maxdecrs comdecrs;
     run;
    %end;
  %end;
  %if %upcase(&procmod)=Y %then %do;
   %if &optnc=1 %then %do;
    data temp;
     file log;
     put "procmod=Y ignored since solution had 1 cluster";
    run;
   %end;
   %else %do;
    %let currnosq=;
    %if %upcase(&nonorm)=Y %then %do;
     %let currnorm=nonorm;
    %end;
    %else %do;
     %let currnorm=;
    %end;
    %if %upcase(&notie)=Y %then %do;
     %let currtie=notie;
    %end;
    %else %do;
     %let currtie=;
    %end;
    %let currnn=;
    %let currrad=;
    %let crrpnlty=;
    %let currbeta=;
    %if %qupcase(%quote(&optmeth))=AVERNOSQ %then %do;
     %let currmeth=average;
     %let currnosq=nosquare;
    %end;
    %else %if %qupcase(%quote(&optmeth))=CENTNOSQ %then %do;
     %let currmeth=centroid;
     %let currnosq=nosquare;
    %end;
    %else %if %qupcase(%quote(&optmeth))=MEDNNOSQ %then %do;
     %let currmeth=median;
     %let currnosq=nosquare;
    %end;
    %else %if %qupcase(%quote(&optmeth))=WARDNOSQ %then %do;
     %let currmeth=ward;
     %let currnosq=nosquare;
    %end;
    %else %if %length(&optmeth)<=4 %then %do;
     %let currmeth=&optmeth;
    %end;
    %else %if %qupcase(%substr(%quote(&optmeth),1,4))=EML: %then %do;
     %let currmeth=EML;
     %let crrpnlty=p=%substr(&optmeth,5);
    %end;
    %else %if %length(&optmeth)<=5 %then %do;
     %let currmeth=&optmeth;
    %end;
    %else %if %qupcase(%substr(%quote(&optmeth),1,5))=FLEX: %then %do;
     %let currmeth=flexible;
     %let currbeta=beta=%substr(&optmeth,6);
    %end;
    %else %if %length(&optmeth)<=7 %then %do;
     %let currmeth=&optmeth;
    %end;
    %else %if %qupcase(%substr(%quote(&optmeth),1,7))=DENSNN: %then %do;
     %let currmeth=density;
     %let currnn=k=%substr(&optmeth,8);
    %end;
    %else %if %qupcase(%substr(%quote(&optmeth),1,7))=2STGNN: %then %do;
     %let currmeth=twostage;
     %let currnn=k=%substr(&optmeth,8);
    %end;
    %else %if %qupcase(%substr(%quote(&optmeth),1,7))=DENSSS: %then %do;
     %let currmeth=density;
     %let currrad=r=%substr(&optmeth,8);
    %end;
    %else %if %qupcase(%substr(%quote(&optmeth),1,7))=2STGSS: %then %do;
     %let currmeth=twostage;
     %let currrad=r=%substr(&optmeth,8);
    %end;
    %else %do;
     %let currmeth=&optmeth;
    %end;
    title6 "Based on the Parsimonious, Nearly Optimal (First Listed) Method";
    %if %quote(&stdizace)^= %then %do;
     * if the variables already exist in the data set, proc aceclus
       adjusts the names of the output variables rather than writing
       over them
     ;
     data lcvclsin;
      set lcvclsin;
      drop &clusvars;
     run;
     proc aceclus 
         data=lcvclsin out=lcvclsin maxiter=100 prefix=_ystd_ noprint
         proportion=&stdizace
         ;
      var &yvars;
     run;
    %end;
    %if %upcase(&optmeth)^=KMEANS %then %do;
     %if &anymiss %then %do;
      proc distance data=lcvclsin out=alldist
       %if %quote(&currnosq)= %then %do;
        method=euclid
       %end;
       %else %do;
        method=sqeuclid
       %end;
      ;
       %if %quote(&clusvars)= %then %do;
        var interval (&yvars);
        copy &yvars &xtravars
         %if &idvar^= %then %do; &idvar %end;
       ;
       %end;
       %else %do;
        var interval (&clusvars);
        copy &yvars &clusvars &xtravars
         %if &idvar^= %then %do; &idvar %end;
       ;
       %end;
      run;
      proc cluster 
       data=alldist method=&currmeth &currnn &currrad
       &currnorm &currtie &currnosq &crrpnlty &currbeta outtree=&outtree
       %if %upcase(&noprint)=Y %then %do; noprint %end;
       simple ccc pseudo rsquare rmsstd print=&listfrom
       %if %upcase(&eignvals)=N %then %do; noeigen %end;
      ;
       var dist1-dist&obscnt;
       %if %quote(&clusvars)= %then %do;
        copy dist1-dist&obscnt &yvars &xtravars;
       %end;
       %else %do;
        copy dist1-dist&obscnt &yvars &clusvars &xtravars;
       %end;
       %if &idvar^= %then %do; id &idvar; %end;
      run;
      proc tree data=&outtree out=&outclus nclusters=&optnc noprint;
       copy dist1-dist&obscnt &clusvars &yvars &xtravars;
       %if &idvar^= %then %do; id &idvar; %end;
      run;
     %end;
     %else %do;
      proc cluster 
       data=lcvclsin method=&currmeth &currnn &currrad &currnorm
       &currtie &currnosq &crrpnlty &currbeta outtree=&outtree
       %if %upcase(&stdize)=Y %then %do;
        standard 
       %end;
       %if %upcase(&noprint)=Y %then %do; noprint %end;
       simple ccc pseudo rsquare rmsstd print=&listfrom
       %if %upcase(&eignvals)=N %then %do; noeigen %end;
      ;
       %if %quote(&clusvars)= %then %do;
        var &yvars;
        copy &yvars &xtravars;
       %end;
       %else %do;
        var &clusvars;
        copy &yvars &clusvars &xtravars;
       %end;
       %if &idvar^= %then %do; id &idvar; %end;
      run;
      proc tree data=&outtree out=&outclus nclusters=&optnc noprint;
       copy &clusvars &yvars &xtravars;
       %if &idvar^= %then %do; id &idvar; %end;
      run;
     %end;
    %end;
    %else %do;
     %if %upcase(&stdize)=Y %then %do;
      * currently used when anymiss is true;
      proc standard 
       data=lcvclsin out=lcvclsin mean=0 std=1 noprint
      ;
       var &clusvars;
      run;
     %end;
     proc fastclus data=lcvclsin maxclusters=&optnc out=&outclus;
      %if %quote(&clusvars)= %then %do;
       var &yvars;
      %end;
      %else %do;
       var &clusvars;
      %end;
      %if &idvar^= %then %do; id &idvar; %end;
     run; 
    %end;
    data &outclus;
     set &outclus;
     * so that outclus has consistent structure;
     keep %if &idvar^= %then %do; &idvar %end;
          &yvars cluster
          %if %upcase(&optmeth)=KMEANS %then %do; distance %end;
     ;
    run;
    proc sort;
     by cluster
     %if &idvar^= %then %do; &idvar %end;
     ;
    run;
    proc means n mean std median min max maxdec=2;
     var &yvars;
     output out=&aveyvars mean=;
     by cluster;
    run;
    data &aveyvars;
     length &clstrvar 8 cluscnt 8;
     set &aveyvars;
     &clstrvar=cluster;
     cluscnt=_freq_;
     drop _type_ _freq_ cluster;
    run;
    data &outclus;
     set &outclus;
     &clstrvar=cluster;
     %if %upcase(&clstrvar)^=CLUSTER %then %do;
      drop cluster;
     %end;
    run;
    %if %upcase(&plotprnt)=Y %then %do;
     proc plot nolegend;
      %do ivar1=1 %to %eval(&yvarcnt-1);
       %do ivar2=%eval(&ivar1+1) %to &yvarcnt;
        plot
         %qscan(&yvars,&ivar1,%str( ))
              *%qscan(&yvars,&ivar2,%str( ))=&clstrvar;
       %end;
      %end;
     quit;
    %end;
   %end;
  %end;
 %end;
 %if  ^&abort & %quote(&outlib)^= %then %do;
  libname clus_out "&outlib";
  %if %upcase(&optmeth)^=KMEANS %then %do;
   data clus_out.&outtree;
    set &outtree;
   run;
  %end;
  data clus_out.&outclus;
   set &outclus;
  run;
  data clus_out.&aveyvars;
   set &aveyvars;
  run;
  libname clus_out clear;
 %end;
 %if ^&abort & %upcase(&testcalc)^=Y %then %do;
/*  proc datasets library=work nolist;*/
/*   delete datacnt temp lcvclsin fold complmnt */
/*          tree compclus lcvscre2 optimal*/
/*          %do inc=&nfst %to &nlst;*/
/*           lcvscr&inc*/
/*          %end;*/
/*   ;*/
/*  run;*/
  quit;
 %end;
 title;
 %if %upcase(&endnotes)=N %then %do;
  options nonotes;
 %end;
 %else %do;
  options notes;
 %end;
%mend;
