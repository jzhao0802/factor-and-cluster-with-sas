* the LCVcluster macro supports likelihood cross-validation for 
  cluster analysis

  several macros to support the LCVcluster macro also included

;
*  last changed on 8/14/14;

* copyright George Knafl all rights reserved;
* permission granted to use this code without warranties of any kind if
  credit is given in published work that computations were performed
  using macros available at http://www.unc.edu/~gknafl/software.html from
  George Knafl, gknafl@unc.edu, Chapel Hill, NC, USA
;

%macro LCVcluster(
    aveyvars=aveyvars,begnotes=N,bestout=bestscrs,BIC=N,ccorrs=SAME,
    clstrvar=clusindx,clusout=clusout,clusvars=,cvarnces=DIFF,
    datain=datain,decrdgts=5,eignvals=N,endnotes=Y,foldcnt=10,
    holdout=,idvar=,initseed=3,keeplevl=0.02,keeptst=Y,listfrom=10,
    maxnclus=20,mindens=1e-100,minnclus=1,minprop=0,minsize=1,
    methlist=WARD,mlistord=N,nclustrs=.,near0eig=0.01,near0std=0.01,
    nocheck=N,nolog=N,nonorm=N,noprint=N,notie=N,outlib=,plotprnt=N,
    printall=N,procmod=Y,scorefmt=9.7,scoreout=scoreout,
    scretype=MIXTURE,stdizace=,stdize=N,stdrange=N,subsetvr=,
    testcalc=N,treeout=treeout,usenmeas=Y,xvrepeat=1,xtravars=,yby=1,
    ycorrs=DIFF,yfst=,ylst=,yprefix=,yvarnces=DIFF,yvars=);
 %if %upcase(&begnotes)=Y %then %do;
  options notes;
 %end;
 %else %do;
  options nonotes;
 %end;
 %global CLUS_errcode;
 %let CLUS_errcode=started;
 %local abort allset anymiss ccobscnt cluscnt clusnext cmpclsnm 
        comment compcnt crrpnlty currad currbeta currmeth currnn
        currnorm currnosq currrad currtie cvarcnt cvnamerr datacnt
        df did1clus dinerr dspart1 dspart2 EMLreqst empparms 
        everzero extra fldparms foldname frstchar hold iclstr if 
        ifold inc ivar ivar1 ivar2 ixv keepval methcnt methnext 
        mincsize mvarcnt mxxvflds namerr newdcnt nfst nlst nmeas 
        nmiss noclstrs nstrt obscnt optmeth optnc othrchar part1 
        part2 SASname scorepos scredgts testcnt treename varscnt 
        varscnt1 varsnext varsnext1 version xtra xvarcnt xvnmerr 
        yvarcnt yvarnext yvarscmp yvnamerr zroparms
 ;
 %let version=20140814;
 %let abort=0;
 %let mxxvflds=350;
 %let scorepos=%qscan(&scorefmt,1,".");
 %let scredgts=%qscan(&scorefmt,2,".");
 %if %upcase(&nocheck)^=Y %then %do;
  %let frstchar=ABCDEFGHIJKLMNOPQRSTUVWXYZ_;
  %let othrchar=&frstchar.0123456789;
  %CLUSchk1();
 %end;
 %if ^&abort %then %do;
  %if &nclustrs=. %then %do;
   %let nfst=&minnclus;
   %let nlst=&maxnclus;
  %end;
  %else %do;
   %let nfst=&nclustrs;
   %let nlst=&nclustrs;
  %end;
  %let zroparms=;
  %do inc=&nfst %to &nlst;
   %let zroparms=&zroparms evrzro&inc;
  %end;
  %let fldparms=fldsiz1_1;
  %do ifold=2 %to &foldcnt;
   %let fldparms=&fldparms fldsiz&ifold._1;
  %end;
  %do ixv=2 %to &xvrepeat;
   %do ifold=2 %to &foldcnt;
    %let fldparms=&fldparms fldsiz&ifold._&ixv;
   %end;
  %end;
  %let empparms=empflds1;
  %do ixv=2 %to &xvrepeat;
   %let empparms=&empparms empflds&ixv;
  %end;
  %local &zroparms &fldparms &empparms;
  %if %upcase(&nocheck)^=Y %then %do;
   %CLUSchk2();
  %end;
  %else %do;
   proc contents data=&datain out=CLUS_datacnt noprint;
   run;
   data CLUS_datacnt;
    set CLUS_datacnt;
    if _n_=1;
    call symput("datacnt",nobs);
   run;
   proc datasets library=work nolist;
    delete CLUS_datacnt;
   run;
   %if %quote(&yvars)= %then %do;
    %let yvarcnt=0;
    %let yvars=;
    %do if=&yfst %to &ylst %by &yby;
     %let yvars=&yvars &yprefix.&if;
     %let yvarcnt=%eval(&yvarcnt+1);
    %end;
   %end;
   data CLUS_datain;
    set &datain;
    %if %upcase(&BIC)^=Y %then %do;
     %do ixv=1 %to &xvrepeat;
      CLUS_randno&ixv=.;
      CLUS_fold&ixv=.;
     %end;
    %end;
    %else %do;
     CLUS_randno1=.;
     CLUS_fold1=1;
    %end;
   run;
   %if %upcase(&BIC)^=Y %then %do;
    proc iml;
     reset noname; * turn off when testing so names come out in prints;
     edit CLUS_datain var _all_;
     %do ixv=1 %to &xvrepeat;
      read all var {CLUS_randno&ixv,CLUS_fold&ixv};
     %end;
     nobs=nrow(CLUS_fold1);
     * the following approach for generating the fold assignments
       guarantees that fold assignments for lower xvrepeat values
       agree with the first so many fold assignments for larger
       xvrepeat values
     ;
     %do ixv=1 %to &xvrepeat;
      do iy=1 to nobs;
       * note that even though the same value of &initseed
         is used in each of these assignment statements
         an updated value of the seed is used after the
         first invocation
       ;
       CLUS_randno&ixv[iy]=uniform(&initseed);
      end;
      CLUS_fold&ixv=int(CLUS_randno&ixv*&foldcnt)+1;
     %end;
     %if &foldcnt=1 %then %do;
      %do ixv=1 %to &xvrepeat;
       randordr=rank(CLUS_randno&ixv);
       ind=(randordr>&holdout*nobs);
       * fold is left equal to 1 on the first &holdout*100% of
         the observations to represent the holdout set and is
         changed to 2 on the rest of the observations to
         represent the training set
       ;
       CLUS_fold&ixv=CLUS_fold&ixv+ind;
       replace all var {CLUS_fold&ixv};
      %end;
     %end;
     %do ixv=1 %to &xvrepeat;
      replace all var {CLUS_randno&ixv,CLUS_fold&ixv};
     %end;
    quit;
   %end;
   proc sort;
    by &yvars;
   run;
   data CLUS_datain;
    set CLUS_datain;
    drop %do ixv=1 %to &xvrepeat;
          CLUS_randno&ixv
         %end;
    ;
   run;
   proc iml;
    reset noname; * turn off when testing so names come out in prints;
    edit CLUS_datain var _all_;
    read all var {&yvars} into y;
    ny=nrow(y);
    yvarcnt=ncol(y);
    nmeas=(y^=.)[+];
    nmiss=(y=.)[+];
    * observations with exactly the same yvars values are
      assigned to the same fold
    ;
    anymiss=0;
    if any(y=.) then do;
     anymiss=1;
    end;
    continue=1;
    %let ixv=0;
    %do ixv=1 %to &xvrepeat;
     if continue then do;
      read all var {CLUS_fold&ixv};
      do iy=2 to ny;
       if y[iy,]=y[iy-1,] then
        CLUS_fold&ixv[iy]=CLUS_fold&ixv[iy-1];
      end;
      replace all var {CLUS_fold&ixv};
      foldcnt=repeat(0,&foldcnt,1);
      %do ifold=1 %to &foldcnt;
       foldcnt[&ifold]=(CLUS_fold&ixv=&ifold)[+];
      %end;
      emptyflds=(foldcnt=0)[+];
      maxfsize=foldcnt[<>];
      %do ifold=1 %to &foldcnt;
       call symput("fldsiz&ifold._&ixv",compress(char(foldcnt[&ifold])));
      %end;
      * not currently using these macro parameters, but left in for
        for possible later use
      ;
      call symput("empflds&ixv",compress(char(emptyflds)));
     end; * end of continue check;
    %end;
    %if &foldcnt=1 %then %do;
     testcnt=ny-foldcnt[1];
    %end;
    %else %do;
     testcnt=ny;
    %end;
    %if %upcase(&keeptst)=Y %then %do;
     * DF computed as change in # of paramters witjh 1 less cluster;
     %if %upcase(&ccorrs)=SAME %then %do;
      %if %upcase(&cvarnces)=SAME %then %do;
       * change in # of parameters 0, so use smallest possible DF;
       DF=1;
      %end;
      %else %do;
       * 1 less variance for each yvars variable;
       DF=yvarcnt;
      %end;
     %end;
     %else %do;
      %if %upcase(&cvarnces)=SAME %then %do;
       * 1 less correlation for each distinct pair of yvar variables;
       DF=yvarcnt*(yvarcnt-1)/2;
      %end;
      %else %do;
       * 1 less covariance for each pair of yvars variable;
       DF=yvarcnt*(yvarcnt+1)/2;
      %end;
     %end;
     keepval=1-exp(-cinv(0.95,DF)/(2*nmeas))*&keeplevl/0.02;
    %end;
    %else %do;
     keepval=&keeplevl;
    %end;
    call symput("obscnt",compress(char(ny)));
    call symput("yvarcnt",compress(char(yvarcnt)));
    call symput("testcnt",compress(char(testcnt)));
    call symput("anymiss",compress(char(anymiss)));
    call symput("keepval",compress(char(keepval)));
    call symput("nmeas",compress(char(nmeas)));
    call symput("nmiss",compress(char(nmiss)));
    call symput("DF",compress(char(DF)));
   quit;
   data CLUS_datain;
    set CLUS_datain;
    %if %quote(&subsetvr)^= %then %do;
     if &subsetvr;
    %end;
    %if %upcase(&stdize)=Y | %upcase(&stdrange)=Y | %quote(&stdizace)^=
    %then %do;
     %do ivar=1 %to &yvarcnt;
      _ystd_&ivar=.;
      %let clusvars=&clusvars _ystd_&ivar;
     %end;
    %end;
   run;
   %if %upcase(&stdize)=Y | %upcase(&stdrange)=Y %then %do;
    proc iml;
     reset noname; * turn off when testing so names come out in prints;
     edit CLUS_datain var _all_;
     read all var {&yvars} into y;
     ny=nrow(y);
     * handle stdize=Y if necessary;
     %if %upcase(&stdize)=Y %then %do;
      read all var {&clusvars};
      %do ivar=1 %to &yvarcnt;
       _ystd_&ivar=y[,&ivar];
      %end;
      replace all var {&clusvars};
     %end;
     %if %upcase(&stdrange)=Y %then %do;
      read all var {&clusvars};
      miny=y[><,];
      maxy=y[<>,];
      %do ivar=1 %to &yvarcnt;
       if maxy[1,&ivar]>miny[1,&ivar] then do;
        _ystd_&ivar=(y[,&ivar]-miny[1,&ivar])/(maxy[1,&ivar]-miny[1,&ivar]);
       end;
       else do;
        ny=nrow(y);
        _ystd_&ivar=repeat(.,ny,1);
        _ystd_&ivar[loc(y[,&ivar]^=.)]=1; 
            * using 1 as the lim(x/x) as x converges to 0;
       end;
      %end;
      replace all var {&clusvars};
     %end;
    quit;
   %end;
  %end;
 %end;
 %if ^&abort %then %do;
  data CLUS_datacopy;
   set CLUS_datain;
  run;
  %if %quote(&stdizace)^= %then %do;
   * if the variables already exist in the data set, proc aceclus
     adjusts the names of the output variables rather than writing
     over them
   ;
   data CLUS_datacopy;
    set CLUS_datain;
    drop &clusvars;
   run;
   proc aceclus 
        data=CLUS_datacopy out=CLUS_datacopy maxiter=100 
        prefix=_ystd_ noprint proportion=&stdizace
   ;
    var &yvars;
   run;
  %end;
  %do ixv=1 %to &xvrepeat;
   %let methcnt=1;
   %let methnext=%qscan(&methlist,&methcnt,%str( ));
   %let did1clus=0;
   %do %while (%quote(&methnext)^=); * beginning of methods loop;
    %let currnosq=;
    %if %upcase(&nonorm)=Y %then %do;
     %let currnorm=nonorm;
    %end;
    %else %do;
     %let currnorm=;
    %end;
    %if %upcase(&notie)=Y %then %do;
     %let currtie=notie;
    %end;
    %else %do;
     %let currtie=;
    %end;
    %let currnn=;
    %let currrad=;
    %let crrpnlty=;
    %let currbeta=;
    %if %qupcase(%quote(&methnext))=AVERNOSQ %then %do;
     %let currmeth=average;
     %let currnosq=nosquare;
    %end;
    %else %if %qupcase(%quote(&methnext))=CENTNOSQ %then %do;
     %let currmeth=centroid;
     %let currnosq=nosquare;
    %end;
    %else %if %qupcase(%quote(&methnext))=MEDNNOSQ %then %do;
     %let currmeth=median;
     %let currnosq=nosquare;
    %end;
    %else %if %qupcase(%quote(&methnext))=WARDNOSQ %then %do;
     %let currmeth=ward;
     %let currnosq=nosquare;
    %end;
    %else %if %length(&methnext)<=4 %then %do;
     %let currmeth=&methnext;
    %end;
    %else %if %qupcase(%substr(%quote(&methnext),1,4))=EML: %then %do;
     %let currmeth=EML;
     %let crrpnlty=penalty=%substr(&methnext,5);
    %end;
    %else %if %length(&methnext)<=5 %then %do;
     %let currmeth=&methnext;
    %end;
    %else %if %qupcase(%substr(%quote(&methnext),1,5))=FLEX: %then %do;
     %let currmeth=flexible;
     %let currbeta=beta=%substr(&methnext,6);
    %end;
    %else %if %length(&methnext)<=7 %then %do;
     %let currmeth=&methnext;
    %end;
    %else %if %qupcase(%substr(%quote(&methnext),1,7))=DENSNN: %then %do;
     %let currmeth=density;
     %let currnn=k=%substr(&methnext,8);
    %end;
    %else %if %qupcase(%substr(%quote(&methnext),1,7))=2STGNN: %then %do;
     %let currmeth=twostage;
     %let currnn=k=%substr(&methnext,8);
    %end;
    %else %if %qupcase(%substr(%quote(&methnext),1,7))=DENSSS: %then %do;
     %let currmeth=density;
     %let currrad=r=%substr(&methnext,8);
    %end;
    %else %if %qupcase(%substr(%quote(&methnext),1,7))=2STGSS: %then %do;
     %let currmeth=twostage;
     %let currrad=r=%substr(&methnext,8);
    %end;
    %else %do;
     %let currmeth=&methnext;
    %end;
    %if %upcase(&nolog)=N %then %do;
     data CLUS_temp;
      file log;
      %if &xvrepeat=1 %then %do;
       put "working on method=&methnext";
      %end;
      %else %do;
       put "cross-validation iteration &ixv for method=&methnext";
      %end;
     run;
    %end;
    %if &ixv=1 %then %do;
     ods exclude all;
     ods results off;
     %if %upcase(&currmeth)^=KMEANS %then %do;
      %if &anymiss %then %do;
       proc distance data=CLUS_datacopy out=CLUS_copydist
        %if %quote(&currnosq)= %then %do;
         method=euclid
        %end;
        %else %do;
         method=sqeuclid
        %end;
       ;
        %if %quote(&clusvars)= %then %do;
         var interval (&yvars);
         copy &yvars;
        %end;
        %else %do;
         var interval (&clusvars);
         copy &yvars &clusvars;
        %end;
       run;
       proc cluster 
        data=CLUS_copydist method=&currmeth &currnn &currrad
         &currnorm &currtie &currnosq &crrpnlty &currbeta
         outtree=CLUS_copytree 
       ;
        var dist1-dist&datacnt;
        %if %quote(&clusvars)= %then %do;
         copy &yvars;
        %end;
        %else %do;
         copy &yvars &clusvars;
        %end;
       run;
      %end;
      %else %do;
       proc cluster 
        data=CLUS_datacopy method=&currmeth &currnn &currrad
        &currnorm &currtie &currnosq &crrpnlty &currbeta
        %if %upcase(&stdize)=Y %then %do;
         standard 
        %end;
        outtree=CLUS_copytree 
       ;
        %if %quote(&clusvars)= %then %do;
         var &yvars;
        %end;
        %else %do;
         var &clusvars;
         copy &yvars &clusvars;
        %end;
       run;
      %end; 
     %end;
     ods results on;
     ods exclude none;
    %end;
    %let nstrt=%eval(&nfst+&did1clus);
    %do inc=&nstrt %to &nlst;
     %if &inc=1 %then %do;
      %let did1clus=1;
     %end;
     %let evrzro&inc=0;
     %if &ixv=1 %then %do;
      ods exclude all;
      ods results off;
      %if %upcase(&currmeth)^=KMEANS %then %do;
       proc tree  
        data=CLUS_copytree out=CLUS_copyclus nclusters=&inc noprint
       ;
       %if %quote(&clusvars)= %then %do;
        copy &yvars;
       %end;
       %else %do;
        copy &clusvars &yvars;
       %end;
       run;
      %end;
      %else %do;
       %if %upcase(&stdize)=Y %then %do;
        * not currently used;
        proc standard 
         data=CLUS_datacopy out=CLUS_datacopy mean=0 std=1 noprint
        ;
         var &clusvars;
        run;
       %end;
       proc fastclus 
        data=CLUS_datacopy maxclusters=&inc noprint out=CLUS_copyclus
       ;
        %if %quote(&clusvars)= %then %do;
         var &yvars;
        %end;
        %else %do;
         var &clusvars;
        %end;
       run; 
      %end;
      ods results on;
      ods exclude none;
      proc iml;
       reset noname; * turn off when testing so names come out in prints;
       edit CLUS_copyclus var _all_;
       read all var _all_;
       ind=(cluster=1);
       mincsize=(cluster[loc(ind)])[+];
       %do iclstr=2 %to &inc;
        ind=(cluster=&iclstr);
        currsize=ind[+];
        if currsize<mincsize then
         mincsize=currsize;
       %end;
       call symput("mincsize",compress(char(mincsize)));
      quit;
     %end;
     data CLUS_lcvscr&inc;
      length method $ 12;
      xvindex=&ixv;
      %if &inc=1 %then %do;
       method="--";
      %end;
      %else %do;
       method="%upcase(&methnext)";
      %end;
      methord=&methcnt;
      nonorm="%upcase(&nonorm)";
      nclstrs=&inc;
      lcvvalue=0;
      %if &ixv=1 %then %do;
       mincsize=&mincsize;
      %end;
      %else %do;
       mincsize=.;
      %end;
      label xvindex="Cross-Validation Index"
            method="Method"
            methord="Method Order"
            nonorm="Nonorm On?"
            nclstrs="# of Clusters"
            lcvvalue="LCV Score"
            mincsize="Minimum Cluster Size"
            ;
      %if %upcase(&BIC)=Y %then %do;
       bicvalue=0;
       label bicvalue="BIC Score";
      %end;
     run;
    %end;
    %let noclstrs=0;
    %do ifold=1 %to &foldcnt;
     %if %upcase(&testcalc)=Y %then %do;
      %let foldname=CLUS_fold&ifold._&ixv;
     %end;
     %else %do;
      %let foldname=CLUS_fold;
     %end;
     data &foldname;
      set CLUS_datain;
      if CLUS_fold&ixv=&ifold;
     run;
     %if &&fldsiz&ifold._&ixv>0 & ^&&noclstrs %then %do;
      data CLUS_complmnt;
       set CLUS_datain;
       %if %upcase(&BIC)^=Y %then %do;
        if CLUS_fold&ixv^=&ifold;
       %end;
      run;
      proc iml;
       reset noname; * turn off when testing so names come out in prints;
       edit CLUS_complmnt var _all_;
       read all var {&yvars} into y;
       ny=nrow(y);
       call symput("compcnt",compress(char(ny)));
      quit;
      %if %upcase(&stdrange)=Y %then %do;
       proc iml;
        reset noname; * turn off when testing so names come out in prints;
        edit CLUS_complmnt var _all_;
        read all var {&yvars} into y;
        read all var {&clusvars};
        miny=y[><,];
        maxy=y[<>,];
        %do ivar=1 %to &yvarcnt; 
         if maxy[1,&ivar]>miny[1,&ivar] then do;
          _ystd_&ivar=(y[,&ivar]-miny[1,&ivar])
                          /(maxy[1,&ivar]-miny[1,&ivar]);
         end;
         else do;
          ny=nrow(y);
          _ystd_&ivar=repeat(.,ny,1);
          _ystd_&ivar[loc(y[,&ivar]^=.)]=1; 
                * using 1 as the lim(x/x) as x converges to 0;
         end;
        %end;
        replace all var {&clusvars};
       quit;
      %end;
      %if %quote(&stdizace)^= %then %do;
       * if the variables already exist in the data set, proc aceclus
         adjusts the names of the output variables rather than writing
         over them
       ;
       data CLUS_complmnt;
        set CLUS_complmnt;
        drop &clusvars;
       run;
       proc aceclus 
           data=CLUS_complmnt out=CLUS_complmnt maxiter=100 
           prefix=_ystd_ noprint proportion=&stdizace
           ;
        var &yvars;
       run;
      %end;
      ods exclude all;
      ods results off;
      %if %upcase(&currmeth)^=KMEANS %then %do;
       %if &anymiss %then %do;
        proc distance data=CLUS_complmnt out=CLUS_compdist
         %if %quote(&currnosq)= %then %do;
          method=euclid
         %end;
         %else %do;
          method=sqeuclid
         %end;
        ;
         %if %quote(&clusvars)= %then %do;
          var interval (&yvars);
          copy &yvars;
         %end;
         %else %do;
          var interval (&clusvars);
          copy &yvars &clusvars;
         %end;
        run;
        proc cluster 
         data=CLUS_compdist method=&currmeth &currnn &currrad
          &currnorm &currtie &currnosq &crrpnlty &currbeta
          %if %upcase(&testcalc)=Y %then %do;
           outtree=CLUS_tree&ifold._&ixv 
          %end;
          %else %do;
           outtree=CLUS_tree 
          %end;
        ;
         var dist1-dist&compcnt;
         %if %quote(&clusvars)= %then %do;
          copy &yvars;
         %end;
        %else %do;
          copy &yvars &clusvars;
         %end;
        run;
       %end;
       %else %do;
        proc cluster 
         data=CLUS_complmnt method=&currmeth &currnn &currrad
         &currnorm &currtie &currnosq &crrpnlty &currbeta
         %if %upcase(&stdize)=Y %then %do;
          standard 
         %end;
         %if %upcase(&testcalc)=Y %then %do;
          outtree=CLUS_tree&ifold._&ixv 
         %end;
         %else %do;
          outtree=CLUS_tree 
         %end;
        ;
         %if %quote(&clusvars)= %then %do;
          var &yvars;
         %end;
         %else %do;
          var &clusvars;
          copy &yvars &clusvars;
         %end;
        run;
       %end; 
      %end;
      ods results on;
      ods exclude none;
      %do inc=&nstrt %to &nlst; * beginning of clusters loop;
       %let everzero=&&evrzro&inc;
       %if ^&everzero & ^&noclstrs %then %do;
        ods exclude all;
        ods results off;
        %if %upcase(&testcalc)=Y %then %do;
         %let treename=CLUS_tree&ifold._&ixv;
         %let cmpclsnm=CLUS_cmpcls&ifold._&ixv; 
        %end;
        %else %do;
         %let treename=CLUS_tree;
         %let cmpclsnm=CLUS_compclus; 
        %end;
        %if %upcase(&currmeth)^=KMEANS %then %do;
         proc tree  
          data=&treename out=&cmpclsnm nclusters=&inc noprint
         ;
         %if %quote(&clusvars)= %then %do;
          copy &yvars;
         %end;
         %else %do;
          copy &clusvars &yvars;
         %end;
         run;
        %end;
        %else %do;
         %if %upcase(&stdize)=Y %then %do;
          * not currently used;
          proc standard 
           data=CLUS_complmnt out=CLUS_complmnt mean=0 std=1 noprint
          ;
           var &clusvars;
          run;
         %end;
         proc fastclus 
          data=CLUS_complmnt maxclusters=&inc
          noprint out=&cmpclsnm
         ;
          %if %quote(&clusvars)= %then %do;
           var &yvars;
          %end;
          %else %do;
           var &clusvars;
          %end;
         run; 
        %end;
        proc contents data=&cmpclsnm out=CLUS_ccobscnt noprint;
        run;
        ods results on;
        ods exclude none;
        data CLUS_ccobscnt;
         set CLUS_ccobscnt;
         if _n_=1;
         call symput("ccobscnt",nobs);
        run;
        %if &ccobscnt>0 %then %do;
         proc sort data=&cmpclsnm;
          by cluster;
         run;
        %end;
        proc iml symsize=4000 worksize=4000;
         %if %upcase(&testcalc)^=Y %then %do;
          reset noname; 
         %end;
         nocalc=0;
         everzero=0;
         edit &foldname var _all_;
         read all var {&yvars} into fy;
         fycnt=ncol(fy);
         fn=nrow(fy);
         %if %upcase(&testcalc)=Y %then %do;
          print fycnt fn;
         %end;
         %if %quote(&idvar)^= %then %do;
          read all var {&idvar} into fid;
         %end;
         %if &ccobscnt=0 %then %do;
          print "empty cluster solution method=&methnext";
          nocalc=1;
          %let noclstrs=1;
         %end;
         %else %do;
          edit &cmpclsnm var _all_;
          read all var {cluster};
          read all var {&yvars} into cy;
          cycnt=ncol(cy); * cycnt and fycnt will be equal;
          cn=nrow(cy);
          %if %upcase(&testcalc)=Y %then %do;
           print cycnt cn;
          %end;
          cluscnt=repeat(0,&inc,1);
          cprop=repeat(0,&inc,1);
          cmean=repeat(0,&inc,cycnt);
          pi=3.14159265358979;
         %end;
         cyind=(cy^=.);
         %if ^&noclstrs %then %do;
          * load the parameter estimates computed from the current fold
            complement for the mixture of &inc groups, multivariate
            normally distributed with possibly different mean vectors
            loaded into the variable cmean, possibly different
            probabilities for belonging to a group loaded into cprop,
            and possibly different variance vectors and correlation
            matrices loaded into cvar and ccorr&iclstr  
  
            variances are estimated using the usual average sums of
            squares approach summing over sets of observations and
            variables determined by the yvarnces and cvarnces settings 
  
            given the variance estimate that is used, the associated
            estimate of the correlation matrix (when the correlations
            are not treated as being constant) will maximize the 
            likelihood (the argument is similar to the one in Johnson &
            Wichern, Multivariate Statistics, Prentice Hall, 3rd ed.,
            1992 for the case of an unstructured covariance matrix with
            1 cluster), but the variance estimates (and the constant
            correlation estimate) need not be maximum likelihood
            estimates 
  
            when both yvarnces and ycorrs are set to DIFF and cvarnces
            and ccorrs are set either both to SAME or both to DIFF, 
            variance and correlation estimate maximize the likelihood
            (see Symons, 1981 referenced in the SAS Users Guide)
            at least when all the variance estimates are nonzero and
            all estimated correlation matrices are non-singular, but
            this may no longer hold for the other degenerate cases due
            to their special handling 
  
            even if nondegenerate estimates are possible for a cluster
            with degenerate standard covariance estimates through
            combining the data in that cluster with data from other
            clusters, this is not done to reduce the chance of 
            generating degenerate clusters in the selected cluster
            solution
          ;
          csumsqs=repeat(0,&inc,cycnt);
          csumcnt=repeat(0,&inc,cycnt);
          cvar=repeat(0,&inc,cycnt);
          do iclstr=1 to &inc;
           ind=(cluster=iclstr);
           cluscnt[iclstr]=ind[+];
           cprop[iclstr]=cluscnt[iclstr]/cn;
           do ivar=1 to cycnt;
            ind2=ind#cyind[,ivar];
            if ind2[+]>0 then do;
             cyhold=cy[loc(ind2),ivar];
             cmean[iclstr,ivar]=cyhold[+]/ind2[+];
            end;
           end;
           do ivar=1 to cycnt;
            ind2=ind#cyind[,ivar];
            if ind2[+]>0 then do;
             cyhold=cy[loc(ind2),ivar];
             diffy=cyhold-cmean[iclstr,ivar];
             csumsqs[iclstr,ivar]=(diffy#diffy)[+];
            end;
            csumcnt[iclstr,ivar]=ind2[+];
           end;
          end;
          pparmcnt=&inc-1; * # distinct cluster proportions;
          mparmcnt=cycnt*&inc; * # of distinct means;
          %if %upcase(&testcalc)=Y %then %do;
           print "before", csumsqs;
          %end;
          %if %upcase(&yvarnces)=SAME & %upcase(&cvarnces)=SAME %then %do;
           vparmcnt=1; * # distinct variances;
           ind=(csumcnt>0);
           cvarhold=csumsqs[+];
           cvarcnt=ind[+];
           if cvarcnt>0 then do;
            cvar[loc(ind)]=cvarhold/cvarcnt;
           end;
          %end;
          %else %if %upcase(&yvarnces)=SAME & %upcase(&cvarnces)=DIFF 
          %then %do;
           vparmcnt=&inc; * # distinct variances;
           %do iclstr=1 %to &inc;
            ind=(csumcnt[&iclstr,]>0);
            cvarhold=csumsqs[&iclstr,+];
            if ind[+]>0 then do;
             cvar[&iclstr,loc(ind)]=cvarhold/ind[+];
            end;
           %end;
          %end;
          %else %if %upcase(&yvarnces)=DIFF & %upcase(&cvarnces)=SAME 
          %then %do;
           vparmcnt=cycnt; * # distinct variances;
           do ivar=1 to cycnt;
            ind=(csumcnt[,ivar]>0);
            cvarcnt=csumcnt[+,ivar];
            cvarhold=csumsqs[+,ivar];
            if cvarcnt>0 then do;
             cvar[loc(ind),ivar]=cvarhold/cvarcnt;
            end;
           end;
          %end;
          %else %do; * the both DIFF case;
           vparmcnt=&inc*cycnt; * # distinct variances;
           do iclstr=1 to &inc;
            do ivar=1 to cycnt;
             if csumcnt[iclstr,ivar]>0 then do;
              cvar[iclstr,ivar]=csumsqs[iclstr,ivar]/csumcnt[iclstr,ivar];
             end;
            end;
           end;
          %end;
          cstd=cvar##0.5;
          nearzero=(cstd<&near0std);
          if nearzero[+]>0 then do;
           cstd[loc(nearzero)]=&near0std;
          end;
          prodcstd=repeat(1,&inc,1);
          overcstd=repeat(0,&inc,cycnt);
          do iclstr=1 to &inc;
           do ivar=1 to cycnt;
             prodcstd[iclstr]=prodcstd[iclstr]*cstd[iclstr,ivar];
             overcstd[iclstr,ivar]=1/cstd[iclstr,ivar];
           end;
          end;
          %if %upcase(&ycorrs)=ZERO %then %do;
           cparmcnt=0; * number of distinct correlations;
           %do iclstr=1 %to &inc;
             ccorr&iclstr=i(cycnt);
           %end;
          %end;
          %else %do;
           %do iclstr=1 %to &inc;
            ccorr0&iclstr=repeat(0,cycnt,cycnt);
            ccnt&iclstr=repeat(0,cycnt,cycnt);
            ind=(cluster=&iclstr);
            cyhold=cy[loc(ind),];
            do ivar1=1 to cycnt-1;
             do ivar2=ivar1+1 to cycnt;
              ind2=(cyhold[,ivar1]^=.)#(cyhold[,ivar2]^=.);
              * print ivar1 ivar2, ind2 cyhold, (ind2[+]);
              if ind2[+]>0 then do;
               diff1=(cyhold[loc(ind2),ivar1]
                          -cmean[&iclstr,ivar1]);
               zdiff1=diff1*overcstd[&iclstr,ivar1];
               diff2=(cyhold[loc(ind2),ivar2]
                          -cmean[&iclstr,ivar2]);
               zdiff2=diff2*overcstd[&iclstr,ivar2];
               ccorr0&iclstr[ivar1,ivar2]=(zdiff1#zdiff2)[+];
              end;
              ccnt&iclstr[ivar1,ivar2]=ind2[+];
             end;
            end;
            %if %upcase(&testcalc)=Y %then %do;
             print "before", ccorr0&iclstr;
            %end;
           %end;
           %if %upcase(&ycorrs)=SAME & %upcase(&ccorrs)=SAME %then %do;
            cparmcnt=1; * number of distinct correlations;
            ccorrhld=0;
            ccnthold=0;
            %do iclstr=1 %to &inc;
             ccorrhld=ccorrhld+ccorr0&iclstr[+];
             ccnthold=ccnthold+ccnt&iclstr[+];
            %end;
            if ccnthold>0 then do;
             ccorrhld=ccorrhld/ccnthold;
            end;
            else do;
             ccorrhld=0;
            end;
            %do iclstr=1 %to &inc;
             ccorr&iclstr=i(cycnt)+ccorrhld*(j(cycnt,cycnt)-diag(ind));
            %end;
           %end;
           %else %if %upcase(&ycorrs)=SAME & %upcase(&ccorrs)=DIFF 
           %then %do;
            cparmcnt=&inc; * number of distinct correlations;
            %do iclstr=1 %to &inc;
             ccorrhld=ccorr0&iclstr[+];
             ccnthold=ccnt&iclstr[+];
             if ccnthold>0 then do;
              ccorrhld=ccorrhld/ccnthold;
             end;
             else do;
              ccorrhld=0;
             end;
             ccorr&iclstr=i(cycnt)+ccorrhld*(j(cycnt,cycnt)-diag(ind));
            %end;
           %end;
           %else %if %upcase(&ycorrs)=DIFF & %upcase(&ccorrs)=SAME 
           %then %do;
            cparmcnt=cycnt*(cycnt-1)/2; * number of distinct correlations;
            ccorrhld=repeat(0,cycnt,cycnt);
            ccnthold=repeat(0,cycnt,cycnt);
            %do iclstr=1 %to &inc;
             ccorrhld=ccorrhld+ccorr0&iclstr;
             ccnthold=ccnthold+ccnt&iclstr;
            %end;
            ind=(ccnthold^=0);
            if ind[+]>0 then do;
             ccorrhld[loc(ind)]=ccorrhld[loc(ind)]/ccnthold[loc(ind)];
            end;
            %do iclstr=1 %to &inc;
             jind=j(cycnt,cycnt);
             ccorr&iclstr=ccorrhld#jind+i(cycnt)+(ccorrhld#jind)`;
            %end;
           %end;
           %else %do; * the both DIFF case;
            cparmcnt=&inc*cycnt*(cycnt-1)/2;
               * number of distinct correlations;
            %do iclstr=1 %to &inc;
             ccorrhld=repeat(0,cycnt,cycnt);
             ind=(ccnt&iclstr^=0);
             if ind[+]>0 then do;
              ccorrhld[loc(ind)]=ccorr0&iclstr[loc(ind)]/ccnt&iclstr[loc(ind)];
             end;
             jind=j(cycnt,cycnt);
             ccorr&iclstr=ccorrhld#jind+i(cycnt)+(ccorrhld#jind)`;
            %end;
           %end;
          %end;
          parmcnt=pparmcnt+mparmcnt+vparmcnt+cparmcnt;
          %if %upcase(&testcalc)=Y %then %do;
           print pparmcnt mparmcnt vparmcnt cparmcnt parmcnt;
          %end; 
          * it is possible in some cases, for example, when
            cvarnces=SAME and CCORRS=DIFF for correlation
            estimates to be distinctly less than -1 or
            distinctly > +1, but such cases will generate
            zero likelihood scores and so tend to not be selected

            it is also possible to get degenerate cases of exactly
            +1 or -1 which means associated pairs of y variables
            are treated as having values on an exact straight line
            these cases will also generate zero likelihood scores
            even for observations in the fold whose values for the 
            associated coordinates are on those lines
          ;
          %do iclstr=1 %to &inc;
           unitcorr&iclstr=0;
           ind=(ccorr&iclstr#(j(cycnt)-i(cycnt))<-1+1e-5);
           if ind[+]>0 then do;
            unitcorr&iclstr=1;
           end;
           ind=(ccorr&iclstr#(j(cycnt)-i(cycnt))>1-1e-5);
           if ind[+]>0 then do;
            unitcorr&iclstr=1;
           end;
          %end;
          %do iclstr=1 %to &inc;
           ccov&iclstr=diag(cstd[&iclstr,])*ccorr&iclstr*diag(cstd[&iclstr,]);
          %end;
          %if %upcase(&testcalc)=Y %then %do;
           print cluscnt cprop cmean cvar cstd prodcstd overcstd;
           %do iclstr=1 %to &inc;
            print unitcorr&iclstr ccorr&iclstr;
            print ccov&iclstr;  
           %end;
          %end;
          detval=repeat(.,&inc,1);
          %do iclstr=1 %to &inc;
           eignvals=eigval(ccorr&iclstr);
           nearzero=(eignvals<&near0eig); 
           if nearzero[+]>0 then do;
            eignvecs=eigvec(ccorr&iclstr);
            adjeigns=eignvals;
            adjeigns[loc(nearzero)]=&near0eig;
            ccorr&iclstr=eignvecs*diag(adjeigns)*eignvecs`;
            %if %upcase(&testcalc)=Y %then %do;
             print eignvals adjeigns "iclstr=&iclstr";
            %end;
            eignvals=adjeigns;
           end;
           ldetcrr=(log(eignvals))[+];
           detval[&iclstr]=exp(-ldetcrr/2);
           invccorr&iclstr=ginv(ccorr&iclstr);
           invccov&iclstr=
             diag(overcstd[&iclstr,])*invccorr&iclstr*diag(overcstd[&iclstr,]);
           invccovb&iclstr=ginv(ccov&iclstr);
           %if %upcase(&testcalc)=Y %then %do;
            print invccorr&iclstr;
            print invccov&iclstr;
            print invccovb&iclstr;
           %end;
          %end;
          %if %upcase(&testcalc)=Y %then %do;
           print detval;
          %end;
          * calculate contribution to LCV score for fold;
           clusdens=repeat(0,&inc,1);
           clusll=0;
           fyind=(fy^=.);
           nfy=fyind[+];
           do if=1 to fn;
            %do iclstr=1 %to &inc;
             diffy=(fy[if,loc(fyind[if,])]
                        -cmean[&iclstr,loc(fyind[if,])]);
             zdiffy=repeat(0,1,cycnt);
             zdiffy[1,loc(fyind[if,])]=
                     diffy#overcstd[&iclstr,loc(fyind[if,])];
              lhold=log(detval[&iclstr]/prodcstd[&iclstr]);
             %if %upcase(&testcalc)=Y %then %do;
              normval=-zdiffy*invccorr&iclstr*zdiffy`/2;
              hold1=zdiffy*invccorr&iclstr;
              print zdiffy hold1;
              print normval lhold "iclstr=&iclstr" if;
              print (exp(-zdiffy*invccorr&iclstr*zdiffy`/2+lhold))
                    (-zdiffy*invccorr&iclstr*zdiffy`/2+lhold);
             %end;
             clusdens[&iclstr]=exp(-zdiffy*invccorr&iclstr*zdiffy`/2+lhold);
             * zero density values increased to a small nonzero amount;
             clusdens[&iclstr]=max(clusdens[&iclstr],&mindens);
            %end;
            %if %upcase(&scretype)=EXPECTED %then %do;
             wgtddens=cprop#clusdens;
             cluswgts=wgtddens/wgtddens[+];
             %if %upcase(&testcalc)=Y %then %do;
              print cprop clusdens wgtddens cluswgts;
             %end;
             ind=(cluswgts>0);
             densterm=(cluswgts[loc(ind)]#log(wgtddens[loc(ind)]))[+];
            %end;
            %else %if %upcase(&scretype)=MIXTURE %then %do;
             densterm=log((cprop#clusdens)[+]);
            %end;
            %else %do; * so scretype is PREDICTD;
             densterm=log((cprop#clusdens)[<>]);
             * the following tended to favor singleton clusters
               because it ignores cprop and so is not recommended
             ;
             * densterm=log(clusdens[<>]);
            %end;
            clusll=clusll+densterm;
            %if %upcase(&testcalc)=Y %then %do;
             print if everzero densterm clusll clusdens;
            %end;
           end;
           clusll=clusll-nfy/2*log(2*pi); 
           %if %upcase(&testcalc)=Y %then %do;
            print everzero clusll "ifold" &ifold;
           %end; 
           %if %upcase(&BIC)=Y %then %do;
            %if %upcase(&usenmeas)=Y %then %do;
             clusll=clusll-parmcnt*log(nfy)/2;
            %end; 
            %else %do;
             clusll=clusll-parmcnt*log(fn)/2;
            %end; 
            %if %upcase(&testcalc)=Y %then %do;
             print "BIC" clusll parmcnt fn (log(fn)/2 nfy (log(nfy)/2);
            %end; 
           %end;
           * end of fold contribution computation;
          * end of unstructured multivariate normal scoring;
         %end;
         edit CLUS_lcvscr&inc var _all_;
         read all var _all_;
         %if %upcase(&testcalc)=Y %then %do;
          print "before" lcvvalue;
         %end;
         if ^nocalc then do;
          if ^everzero then do;
           %if %upcase(&BIC)=Y %then %do;
            bicvalue=-2*clusll;
            %if %upcase(&testcalc)=Y %then %do;
             print "BIC" bicvalue;
            %end;
            lcvvalue=lcvvalue+clusll/nfy;
           %end;
           %else %if &foldcnt>1 %then %do;
            lcvvalue=lcvvalue+clusll/&nmeas;
           %end;
           %else %do;
            lcvvalue=lcvvalue+clusll/nfy;
           %end;
          end;
          else do;
           lcvvalue=0;
          end;
         end;
         else do;
          lcvvalue=.;
         end;
         %if %upcase(&testcalc)=Y %then %do;
          print "after" lcvvalue;
         %end;
         replace all var {lcvvalue
                          %if %upcase(&BIC)=Y %then %do;
                           ,bicvalue
                          %end;
                         };
         call symput("evrzro&inc",compress(char(everzero)));
        quit;
        * end of not ever zero nor no clusters handling;
       %end;
       %else %if &noclstrs %then %do;
        proc iml;
         edit CLUS_lcvscr&inc var _all_;
         read all var _all_;
         %if %upcase(&testcalc)=Y %then %do;
          print "before" lcvvalue;
         %end;
         lcvvalue=.;
         %if %upcase(&testcalc)=Y %then %do;
          print "after" lcvvalue;
         %end;
         replace all var {lcvvalue};
        quit;
       %end;
       %if %upcase(&testcalc)^=Y %then %do;
        * if not deleted, it will not be replaced if ever empty;
        ods exclude all;
        ods results off;
        proc datasets library=work;
         delete &cmpclsnm;
        run;
        ods results on;
        ods exclude none;
       %end; 
      %end; * end of # clusters loop;
     %end; * end of nonempty fold handling;
    %end; * end of # folds loop;
    %do inc=&nstrt %to &nlst;
     %let everzero=&&evrzro&inc;
     %if ^&everzero %then %do;
      %if %upcase(&testcalc)=Y %then %do;
       proc print data=CLUS_lcvscr&inc; run;
      %end;
      data CLUS_lcvscr&inc;
       set CLUS_lcvscr&inc;
       lcvvalue=exp(lcvvalue);
      run;
     %end;
    %end;
    %if &methcnt=1 & &ixv=1 %then %do;
     data CLUS_lcvscrs;
      set CLUS_lcvscr&nfst;
     run;
     %do inc=%eval(&nfst+1) %to &nlst;
      data CLUS_lcvscrs;
       set CLUS_lcvscrs CLUS_lcvscr&inc;
      run;
     %end;
    %end;
    %else %do; 
     %do inc=&nstrt %to &nlst;
      data CLUS_lcvscrs;
       set CLUS_lcvscrs CLUS_lcvscr&inc;
      run;
     %end;
    %end;
    %if %upcase(&testcalc)=Y %then %do;
     proc print data=CLUS_lcvscrs; run;
    %end;
    %let methcnt=%eval(&methcnt+1);
    %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
   %end; * end of methods loop;
   %let methcnt=%eval(&methcnt-1);
  %end; * end of xvrepeat loop;
  %if %upcase(&noprint)=N %then %do;
   %CLUSprints()
  %end;
  proc iml;
   reset noname; * turn off when testing so names come out in prints;
   edit CLUS_lcvscrs var _all_;
   read all var _all_;
   nobs=nrow(xvindex);
   %let methcnt=1;
   %let methnext=%qscan(&methlist,&methcnt,%str( ));
   %let did1clus=0;
   %do %while (%quote(&methnext)^=); * beginning of methods loop;
    %let nstrt=%eval(&nfst+&did1clus);
    %do inc=&nstrt %to &nlst;
     %if &inc=1 %then %do;
      %let did1clus=1;
      ind1=(method="--" & nclstrs=&inc);
     %end;
     %else %do;
      ind1=(method="%upcase(&methnext)" & nclstrs=&inc);
     %end;
     currmin=(mincsize[loc(ind1)])[<>];
     mincsize[loc(ind1)]=currmin;
     * print "&methnext" &inc currmin;
    %end; * end of # of clusters loop;
    %let methcnt=%eval(&methcnt+1);
    %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
   %end; * end of methods loop;
   %let methcnt=%eval(&methcnt-1);
   replace all var {mincsize};
   newdcnt=(mincsize>=&minsize & mincsize>=&minprop*&datacnt)[+];
   call symput("newdcnt",compress(char(newdcnt)));
  quit;
  %if &newdcnt=0 %then %do;
   proc iml;
    print 
  "no clustering alternatives have minsize>=&minsize and minprop>=&minprop";
   quit;
  %end;
  %else %do;
   data &scoreout;
    set CLUS_lcvscrs;
    if mincsize>=&minsize & mincsize>=&minprop*&datacnt;
   run;
   proc iml;
    reset noname; * turn off when testing so names come out in prints;
    edit &scoreout var _all_;
    read all var _all_;
    nobs=nrow(xvindex);
    sepdecrs=repeat(0,nobs,1);
    %do ixv=1 %to &xvrepeat;
     ind=(xvindex=&ixv);
     maxscore=(lcvvalue[loc(ind)])[<>];
     if maxscore>0 then do;
      sepdecrs[loc(ind)]=(maxscore-lcvvalue[loc(ind)])/maxscore;
     end;
     else do;
      sepdecrs[loc(ind)]=.;
     end;
    %end;
    conf01=repeat(0,nobs,1);
    conf02=repeat(0,nobs,1);
    conf05=repeat(0,nobs,1);
    maxdecrs=repeat(0,nobs,1);
    avedecrs=repeat(0,nobs,1);
    lcvave=repeat(0,nobs,1);
    lcvtrave=repeat(0,nobs,1);
    %let methcnt=1;
    %let methnext=%qscan(&methlist,&methcnt,%str( ));
    %let did1clus=0;
    %do %while (%quote(&methnext)^=); * beginning of methods loop;
     %let nstrt=%eval(&nfst+&did1clus);
     %do inc=&nstrt %to &nlst;
      %if &inc=1 %then %do;
       %let did1clus=1;
       ind1=(method="--" & nclstrs=&inc);
      %end;
      %else %do;
       ind1=(method="&methnext" & nclstrs=&inc);
      %end;
      ind2=(ind1 & sepdecrs^=.);
      if ind2[+]>0 then do;
       confhld1=((sepdecrs[loc(ind2)]<=0.01)[+])/ind1[+];
       confhld2=((sepdecrs[loc(ind2)]<=0.02)[+])/ind1[+];
       confhld5=((sepdecrs[loc(ind2)]<=0.05)[+])/ind1[+];
       maxhold=(sepdecrs[loc(ind2)])[<>];
       ave1hold=(sepdecrs[loc(ind2)])[:];
       ave2hold=(lcvvalue[loc(ind2)])[:];
       %if &xvrepeat>2 %then %do;
        ave3hold=(lcvvalue[loc(ind2)])[+];
        ave3hold=ave3hold-lcvvalue[loc(ind2)][><];
        ave3hold=ave3hold-lcvvalue[loc(ind2)][<>];
        ave3hold=ave3hold/(&xvrepeat-2);
       %end;
       %else %do;
        ave3hold=.;
       %end;
      end;
      else do;
       confhld1=.;
       confhld2=.;
       confhld5=.;
       maxhold=.;
       ave1hold=.;
       ave2hold=.;
       ave3hold=.;
      end;
      if ind1[+]>0 then do;
       conf01[loc(ind1)]=confhld1;
       conf02[loc(ind1)]=confhld2;
       conf05[loc(ind1)]=confhld5;
       maxdecrs[loc(ind1)]=maxhold;
       avedecrs[loc(ind1)]=ave1hold;
       lcvave[loc(ind1)]=ave2hold;
       lcvtrave[loc(ind1)]=ave3hold;
      end;
     %end; * end of # of clusters loop;
     %let methcnt=%eval(&methcnt+1);
     %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
    %end; * end of methods loop;
    %let methcnt=%eval(&methcnt-1);
    comdecrs=repeat(0,nobs,1);
    maxscore=lcvave[<>];
    if maxscore>0 then do;
     comdecrs=(maxscore-lcvave)/maxscore;
    end;
    else do;
     comdecrs=.;
    end;
    create CLUS_lcvscrs2 
       var {xvindex method methord nonorm nclstrs lcvvalue
            sepdecrs conf01 conf02 conf05 maxdecrs avedecrs
            lcvave lcvtrave comdecrs mincsize
            %if %upcase(&BIC)=Y %then %do;
             bicvalue
            %end;
           };
    append;
   quit;
   data &scoreout;
    set CLUS_lcvscrs2;
    label xvindex="Cross-Validation Index"
          method="Method"
          methord="Method Order"
          nclstrs="# of Clusters"
          nonorm="Nonorm On?"
          lcvvalue="LCV Score"
          mincsize="Minumum Cluster Size"
          sepdecrs="Percent Decrease from Best Score"
          conf01="% Time Decrease <= 0.01"
          conf02="% Time Decrease <= 0.02"
          conf05="% Time Decrease <= 0.05"
          maxdecrs="Worst Case Decrease"
          avedecrs="Average Decrease"
          lcvave="LCV Average"
          lcvtrave="Trimmed LCV Average"
          comdecrs="Percent Decrease from Best Average"
          %if %upcase(&BIC)=Y %then %do;
           bicvalue="Bayesian Information Criterion Score"
          %end;
          ;
    format lcvvalue lcvave &scorefmt;
    %if %upcase(&BIC)=Y %then %do;
     format bicvalue &scorefmt;
    %end;
    format maxdecrs %eval(&decrdgts+2).&decrdgts;
    format sepdecrs comdecrs 
           percent%eval(&decrdgts+2).&decrdgts;
    format conf01 conf02 conf05 percent7.1;
   run;
   data &bestout;
    set &scoreout;
    if xvindex=1;
    if comdecrs^=. then do;
     if comdecrs<=&keepval & lcvave^=.;
     *if avedecrs<=&keepval & lcvave^=.;
     *if maxdecrs<=&keepval & lcvave^=.; * possibly empty!;
    end;
   run;
   proc sort;
    %if %upcase(&mlistord)=Y %then %do;
     by comdecrs nclstrs methord;
    %end;
    %else %do;
     by comdecrs nclstrs method;
    %end;
   run;
   %if  %upcase(&printall)=Y & %upcase(&noprint)^=Y %then %do;
    title2 "Clustering Alternatives under Consideration";
    proc print label noobs data=&scoreout;
     %if &xvrepeat=1 %then %do;
      var method nonorm nclstrs lcvvalue sepdecrs mincsize
          %if %upcase(&BIC)=Y %then %do;
           bicvalue
          %end;
      ;
     %end;
     %else %do;
      var xvindex method nonorm nclstrs lcvvalue sepdecrs mincsize;
     %end;
    run;
   %end;
   data CLUS_optimal;
    set &bestout;
    if _n_=1;
    call symput("optnc",nclstrs);
    call symput("optmeth",method);
   run;
   %if %upcase(&mlistord)=Y %then %do;
    %let comment=Ordered by Score, # of Clusters, and Method Listed Order;
   %end;
   %else %do;
    %let comment=Ordered by Score, # of Clusters, and Method Name;
   %end;
   title2 "Competitive Clustering Alternatives";
   title3 "&comment";
   %if %upcase(&noprint)^=Y %then %do;
     %if &xvrepeat=1 %then %do;
      proc print label noobs data=&bestout;
       var method nonorm nclstrs lcvvalue sepdecrs mincsize
           %if %upcase(&BIC)=Y %then %do;
            bicvalue
           %end;
       ;
      run;
     %end;
     %else %do;
      proc print label noobs data=&bestout;
       var method nclstrs nonorm conf01 conf02 lcvave comdecrs mincsize;
      run;
      proc print label noobs data=&bestout;
       var method nclstrs avedecrs maxdecrs comdecrs;
      run;
     %end;
   %end;
   %if %upcase(&procmod)=Y %then %do;
    %if &optnc=1 %then %do;
     %if %upcase(&nolog)=N %then %do;
      data CLUS_temp;
       file log;
       put "procmod=Y ignored since solution had 1 cluster";
      run;
    %end;
    %end;
    %else %do;
     %let currnosq=;
     %if %upcase(&nonorm)=Y %then %do;
      %let currnorm=nonorm;
     %end;
     %else %do;
      %let currnorm=;
     %end;
     %if %upcase(&notie)=Y %then %do;
      %let currtie=notie;
     %end;
     %else %do;
      %let currtie=;
     %end;
     %let currnn=;
     %let currrad=;
     %let crrpnlty=;
     %let currbeta=;
     %if %qupcase(%quote(&optmeth))=AVERNOSQ %then %do;
      %let currmeth=average;
      %let currnosq=nosquare;
     %end;
     %else %if %qupcase(%quote(&optmeth))=CENTNOSQ %then %do;
      %let currmeth=centroid;
      %let currnosq=nosquare;
     %end;
     %else %if %qupcase(%quote(&optmeth))=MEDNNOSQ %then %do;
      %let currmeth=median;
      %let currnosq=nosquare;
     %end;
     %else %if %qupcase(%quote(&optmeth))=WARDNOSQ %then %do;
      %let currmeth=ward;
      %let currnosq=nosquare;
     %end;
     %else %if %length(&optmeth)<=4 %then %do;
      %let currmeth=&optmeth;
     %end;
     %else %if %qupcase(%substr(%quote(&optmeth),1,4))=EML: %then %do;
      %let currmeth=EML;
      %let crrpnlty=penalty=%substr(&optmeth,5);
     %end;
     %else %if %length(%quote(&optmeth))<=5 %then %do;
      %let currmeth=&optmeth;
     %end;
     %else %if %qupcase(%substr(%quote(&optmeth),1,5))=FLEX: %then %do;
      %let currmeth=flexible;
      %let currbeta=beta=%substr(&optmeth,6);
     %end;
     %else %if %length(&optmeth)<=7 %then %do;
      %let currmeth=&optmeth;
     %end;
     %else %if %qupcase(%substr(%quote(&optmeth),1,7))=DENSNN: %then %do;
      %let currmeth=density;
      %let currnn=k=%substr(&optmeth,8);
     %end;
     %else %if %qupcase(%substr(%quote(&optmeth),1,7))=2STGNN: %then %do;
      %let currmeth=twostage;
      %let currnn=k=%substr(&optmeth,8);
     %end;
     %else %if %qupcase(%substr(%quote(&optmeth),1,7))=DENSSS: %then %do;
      %let currmeth=density;
      %let currrad=r=%substr(&optmeth,8);
     %end;
     %else %if %qupcase(%substr(%quote(&optmeth),1,7))=2STGSS: %then %do;
      %let currmeth=twostage;
      %let currrad=r=%substr(&optmeth,8);
     %end;
     %else %do;
      %let currmeth=&optmeth;
     %end;
     title3 "Based on the Parsimonious, Nearly Optimal (First Listed) Method";
     %if %quote(&stdizace)^= %then %do;
      * if the variables already exist in the data set, proc aceclus
        adjusts the names of the output variables rather than writing
        over them
      ;
      data CLUS_datain;
       set CLUS_datain;
       drop &clusvars;
      run;
      proc aceclus 
          data=CLUS_datain out=CLUS_datain maxiter=100 prefix=_ystd_ noprint
          proportion=&stdizace
          ;
       var &yvars;
      run;
     %end;
     %if %qupcase(%quote(&optmeth))^=KMEANS %then %do;
      %if &anymiss %then %do;
       proc distance data=CLUS_datain out=alldist
        %if %quote(&currnosq)= %then %do;
         method=euclid
        %end;
        %else %do;
         method=sqeuclid
        %end;
       ;
        %if %quote(&clusvars)= %then %do;
         var interval (&yvars);
         copy &yvars &xtravars
          %if &idvar^= %then %do; &idvar %end;
        ;
        %end;
        %else %do;
         var interval (&clusvars);
         copy &yvars &clusvars &xtravars
          %if &idvar^= %then %do; &idvar %end;
        ;
        %end;
       run;
       proc cluster 
        data=alldist method=&currmeth &currnn &currrad
        &currnorm &currtie &currnosq &crrpnlty &currbeta outtree=&treeout
        %if %upcase(&noprint)=Y %then %do; noprint %end;
        simple ccc pseudo rsquare rmsstd print=&listfrom
        %if %upcase(&eignvals)=N %then %do; noeigen %end;
       ;
        var dist1-dist&obscnt;
        %if %quote(&clusvars)= %then %do;
         copy dist1-dist&obscnt &yvars &xtravars;
        %end;
        %else %do;
         copy dist1-dist&obscnt &yvars &clusvars &xtravars;
        %end;
        %if &idvar^= %then %do; id &idvar; %end;
       run;
       proc tree data=&treeout out=&clusout nclusters=&optnc noprint;
        copy dist1-dist&obscnt &clusvars &yvars &xtravars;
        %if &idvar^= %then %do; id &idvar; %end;
       run;
      %end;
      %else %do;
       proc cluster 
        data=CLUS_datain method=&currmeth &currnn &currrad &currnorm
        &currtie &currnosq &crrpnlty &currbeta outtree=&treeout
        %if %upcase(&stdize)=Y %then %do;
         standard 
        %end;
        %if %upcase(&noprint)=Y %then %do; noprint %end;
        simple ccc pseudo rsquare rmsstd print=&listfrom
        %if %upcase(&eignvals)=N %then %do; noeigen %end;
       ;
        %if %quote(&clusvars)= %then %do;
         var &yvars;
         %if %quote(&xtravars)^= %then %do;
          copy &xtravars;
         %end;
        %end;
        %else %do;
         var &clusvars;
         copy &yvars &xtravars;
        %end;
        %if &idvar^= %then %do; id &idvar; %end;
       run;
       proc tree data=&treeout out=&clusout nclusters=&optnc noprint;
        copy &clusvars &yvars &xtravars;
        %if &idvar^= %then %do; id &idvar; %end;
       run;
      %end;
     %end;
     %else %do;
      %if %upcase(&stdize)=Y %then %do;
       * currently used when anymiss is true;
       proc standard 
        data=CLUS_datain out=CLUS_datain mean=0 std=1 noprint
       ;
        var &clusvars;
       run;
      %end;
      proc fastclus data=CLUS_datain maxclusters=&optnc out=&clusout;
       %if %quote(&clusvars)= %then %do;
        var &yvars;
       %end;
       %else %do;
        var &clusvars;
       %end;
       %if &idvar^= %then %do; id &idvar; %end;
      run; 
     %end;
     data &clusout;
      set &clusout;
      * so that clusout has consistent structure;
      keep %if &idvar^= %then %do; &idvar %end;
           &yvars cluster
           %if %qupcase(%quote(&optmeth))=KMEANS %then %do; distance %end;
           &xtravars
      ;
     run;
     proc sort;
      by cluster
      %if &idvar^= %then %do; &idvar %end;
      ;
     run;
     proc means n mean std median min max maxdec=2;
      var &yvars;
      output out=&aveyvars mean=;
      by cluster;
     run;
     data &aveyvars;
      length &clstrvar 8 cluscnt 8;
      set &aveyvars;
      &clstrvar=cluster;
      cluscnt=_freq_;
      drop _type_ _freq_ cluster;
     run;
     data &clusout;
      set &clusout;
      &clstrvar=cluster;
      %if %upcase(&clstrvar)^=CLUSTER %then %do;
       drop cluster;
      %end;
     run;
     %if %upcase(&plotprnt)=Y %then %do;
      proc plot nolegend;
       %do ivar1=1 %to %eval(&yvarcnt-1);
        %do ivar2=%eval(&ivar1+1) %to &yvarcnt;
         plot
          %qscan(&yvars,&ivar1,%str( ))
               *%qscan(&yvars,&ivar2,%str( ))=&clstrvar;
        %end;
       %end;
      quit;
     %end;
    %end;
   %end;
  %end;
 %end;
 %if  ^&abort & %quote(&outlib)^= %then %do;
  libname CLUS_out "&outlib";
  %if %qupcase(%quote(&optmeth))^=KMEANS %then %do;
   data CLUS_out.&treeout;
    set &treeout;
   run;
  %end;
  data CLUS_out.&clusout;
   set &clusout;
  run;
  data CLUS_out.&aveyvars;
   set &aveyvars;
  run;
  libname CLUS_out clear;
 %end;
 %if ^&abort & %upcase(&testcalc)=N %then %do;
  proc datasets library=work nolist;
   delete CLUS_temp CLUS_datain CLUS_complmnt CLUS_lcvscrs 
          CLUS_lcvscrs2 CLUS_optimal CLUS_ccobscnt 
          CLUS_datacopy CLUS_copydist CLUS_copytree 
          CLUS_copyclus CLUS_compdist
          %do inc=&nfst %to &nlst;
           CLUS_lcvscr&inc
          %end;
          %if %upcase(&testcalc)=Y %then %do;
           %do ixv=1 %to &xvrepeat;
            %do ifold=1 %to &foldcnt;
             CLUS_tree&ifold._&ixv CLUS_cmpcls&ifold._&ixv
             CLUS_fold&ifold._&ixv
            %end;
           %end;
          %end;
          %else %do;
           CLUS_tree CLUS_compclus CLUS_fold
          %end;
   ;
  run;
  quit;
  %let CLUS_errcode=completed;
 %end;
 %else %do;
  %if &abort %then %do;
   %let CLUS_errcode=input error;
  %end;
  %else %do;
   %let CLUS_errcode=completed;
  %end;
 %end;
 title;
 %if %upcase(&endnotes)=N %then %do;
  options nonotes;
 %end;
 %else %do;
  options notes;
 %end;
%mend;

%macro CLUSvarsld1(name=clusvars,abbr=c,list=);
 &abbr.varbles=" ";
 %let varscnt=1;
 %let varsnext=%qscan(&list,&varscnt,%str( ));
 %do %while (&varsnext^=);
  &abbr.varbles=&abbr.varbles//"&varsnext";
  %let varscnt=%eval(&varscnt+1);
  %let varsnext=%qscan(&list,&varscnt,%str( ));
 %end;
 %let varscnt=%eval(&varscnt-1);
 %if &varscnt>0 %then %do;
  &abbr.varbles=&abbr.varbles[2:&varscnt+1];
 %end;
 %let &abbr.varcnt=&varscnt;
%mend CLUSvarsld1;

%macro CLUSnamechk(name=,parm=parm,empty=1,maxlen=32);
 * empty=0 means not an error if an empty setting, empty=1 means
   an error if empty setting
 ;
 %let namerr=0;
 %if %quote(&name)= %then %do;
  %let extra=;
 %end;
 %else %do;
  %let extra=for &name;
 %end;
 %let SASname=%upcase(&parm);
 %if %bquote(&SASname)^= %then %do;
  %if %verify(%bquote(%substr(%bquote(&SASname),1,1)),&frstchar)>0 
  %then %do;
   print 
    "invalid first character of name &parm &extra";
   inpterr=1;
   %let namerr=1;
  %end;
  %else %if %verify(%bquote(&SASname),&othrchar)>0 %then %do;
   print "name &parm &extra not a valid SAS name";
   inpterr=1;
   %let namerr=1;
  %end;
  %if %length(%bquote(&SASname))>&maxlen %then %do;
   print "name &parm &extra is longer than &maxlen characters";
   inpterr=1;
   %let namerr=1;
  %end;
 %end;
 %else %do;
  %if &empty=1 %then %do;
   print "empty specification for name &extra not allowed";
   inpterr=1;
   %let namerr=1;
  %end;
 %end;
%mend CLUSnamechk;

%macro CLUSchk1();
 proc iml;
  reset noname;
  inpterr=0;
  dsfound=0;
  %let dspart1=%scan(&datain,1,.);
  %let dspart2=%scan(&datain,2,.);
  %CLUSnamechk(name=datain,parm=&dspart1);
  %let dinerr=&namerr;
  %if &namerr %then %do;
   inpterr=1;
  %end;
  %CLUSnamechk(name=datain,parm=&dspart2,empty=0);
  %if &namerr %then %do;
   %let dinerr=1;
   inpterr=1;
  %end;
  %if ^&dinerr %then %do;
   %if &dspart2= %then %do;
    dslist=datasets();
    dsname="%upcase(&dspart1)";
    lbname="";
    if nrow(dslist)=0 then do;
     print "empty default library";
     inpterr=1;
    end;
   %end;
   %else %do;
    dslist=datasets(&dspart1);
    if nrow(dslist)=0 then do;
     print "nonexistent or empty library &dspart1";
     inpterr=1;
    end;
    lbname="%upcase(&dspart1)";
    dsname="%upcase(&dspart2)";
   %end;
   if ^inpterr then do;
    if any(dslist=dsname) then
     dsfound=1;
    if ^dsfound then do;
     print "nonexistent data set &datain";
     inpterr=1;
    end;
    else if "%upcase(%substr(&datain.*****,1,5))"="CLUS_" then do;
     print "name of datain data set not allowed to start with CLUS_";
     inpterr=1;
    end;
   end;
  %end;
  call symput("abort",char(inpterr));
  if inpterr then do;
   print "execution canceled";
  end;
 quit;
 %let datacnt=0;
 %if ^&abort %then %do;
  proc contents data=&datain out=CFA_datacnt noprint;
  run;
  data CFA_datacnt;
   set CFA_datacnt;
   if _n_=1;
   call symput("datacnt",compress(nobs));
  run;
  proc datasets library=work nolist;
   delete CFA_datacnt;
  run;
  proc iml;
   reset noname;
   inpterr=0;
   %if &datacnt=0 %then %do;
    print "empty datain data set: &datain";
    inpterr=1;
   %end;
   if ^inpterr then do;
    %if &dspart2= %then %do;
     dslist=datasets();
     dsname="%upcase(&dspart1)";
     lbname="";
    %end;
    %else %do;
     dslist=datasets(&dspart1);
     lbname="%upcase(&dspart1)";
     dsname="%upcase(&dspart2)";
    %end;
    %if &dspart2= %then %do;
     dsvars=contents(dsname);
    %end;
    %else %do;
     dsvars=contents(lbname,dsname);
    %end;
    * print dsvars;
    dsvars=upcase(dsvars);
    %CLUSnamechk(name=subsetvr,parm=&subsetvr,empty=0);
    %if ^&namerr %then %do;
     %if %quote(&subsetvr)^= %then %do;
      if all(dsvars^="%upcase(&subsetvr)") then do;
       print "nonexistent subsetting variable: &subsetvr";
       inpterr=1;
      end;
     %end;
    %end;
   end;
   %if %datatyp(&initseed)^=NUMERIC %then %do;
    print "initseed (&initseed) not numeric";
    inpterr=1;
   %end;
   %else %do;
    %let len=%length(&initseed);
    %let part1=%qscan(%quote(&initseed),1,.ed);
    %if %length(&part1)<&len %then %do;
     print 
      "initseed (&initseed) is in either fixed decimal or scientific notation";
     inpterr=1;
    %end;
    %else %do;
     initseed=&initseed;
     if initseed<3 then do;
      print "initseed (&initseed) less than 3";
      inpterr=1;
     end;
     else if mod(initseed,int(initseed))^=0 then do;
      print "initseed (&initseed) not an integer";
      inpterr=1;
     end;
    %end;
   %end;
   %if %quote(&holdout)^= %then %do;
    %if &foldcnt^=1 %then %do;
     print "holdout (&holdout) not supported with foldcnt^=1";
     inpterr=1;
    %end;
    %if %datatyp(&holdout)^=NUMERIC %then %do;
     print "holdout (&holdout) nonnumeric";
     inpterr=1;
    %end;
    %else %do;
     holdout=&holdout;
     if holdout<=0 | holdout>=1 then do;
      print "holdout (&holdout) must be > 0 and < 1";
      inpterr=1;
     end;
    %end;
   %end;
   maxnclus=.;
   %if %datatyp(&maxnclus)^=NUMERIC %then %do;
    print "maxnclus (&maxnclus) not numeric";
    inpterr=1;
   %end;
   %else %do;
    %let len=%length(&maxnclus);
    %let part1=%qscan(%quote(&maxnclus),1,.ed);
    %if %length(&part1)<&len %then %do;
     print 
      "maxnclus (&maxnclus) is in either fixed decimal or scientific notation";
     inpterr=1;
    %end;
    %else %do;
     maxnclus=&maxnclus;
     if maxnclus<=0 then do;
      print "maxnclus (&maxnclus) not positive";
      inpterr=1;
     end;
     else do;
      if mod(maxnclus,int(maxnclus))^=0 then do;
       print "maxnclus (&maxnclus) not an integer";
       inpterr=1;
      end;
     end;
    %end;
   %end;
   %if %datatyp(&minnclus)^=NUMERIC %then %do;
    print "minnclus (&minnclus) not numeric";
    inpterr=1;
   %end;
   %else %do;
    %let len=%length(&minnclus);
    %let part1=%qscan(%quote(&minnclus),1,.ed);
    %if %length(&part1)<&len %then %do;
     print 
      "minnclus (&minnclus) is in either fixed decimal or scientific notation";
     inpterr=1;
    %end;
    %else %do;
     minnclus=&minnclus;
     if minnclus<=0 then do;
      print "minnclus (&maxnclus) not positive";
      inpterr=1;
     end;
     else do;
      if mod(minnclus,int(minnclus))^=0 then do;
       print "minnclus (&minnclus) not an integer";
       inpterr=1;
      end;
      else if maxnclus^=. then do;
       if minnclus>maxnclus then do;
        print "minnclus (&minnclus) exceeds maxnclus (&maxnclus)";
        inpterr=1;
       end;
      end;
     end;
    %end;
   %end;
   %if %datatyp(&nclustrs)^=NUMERIC & %quote(&nclustrs)^=. %then %do;
    print "nclustrs (&nclustrs) not numeric";
    inpterr=1;
   %end;
   %else %do;
    %if %quote(&nclustrs)^=. %then %do;
     %let len=%length(&nclustrs);
     %let part1=%qscan(%quote(&nclustrs),1,.ed);
     %if %length(&part1)<&len %then %do;
      print 
       "nclustrs (&nclustrs) is in either fixed decimal or scientific notation";
      inpterr=1;
     %end;
     %else %do;
      nclustrs=&nclustrs;
      if nclustrs^=. then do;
       if nclustrs<1 then do;
        print "nclustrs (&nclustrs) not at least 1";
        inpterr=1;
       end;
       else if mod(nclustrs,int(nclustrs))^=0 then do;
        print "nclustrs (&nclustrs) not an integer";
        inpterr=1;
       end; 
      end;
     %end;
    %end;
   %end;
   call symput("abort",char(inpterr));
   if inpterr then do;
    print "execution canceled";
   end;
  quit;
 %end;
 %if ^&abort %then %do;
  proc iml;
   reset noname;
   inpterr=0;
   %if %quote(&subsetvr)^= %then %do;
    edit &datain var {&subsetvr};
    read all var {&subsetvr};
    if type(&subsetvr)^="N" then do;
     print "nonnumeric subsetvr variable: &subsetvr";
     inpterr=1;
    end;
    else if (subsetvr^=. & subsetvr^=0)[+]=0 then do;
     print "subset variable (&subsetvr) generates an empty subset";
     inpterr=1;
    end;
   %end;
   call symput("abort",char(inpterr));
   if inpterr then do;
    print "execution canceled";
   end;
  quit;
 %end;
 %if ^&abort %then %do;
  data CLUS_datain;
   set &datain;
  run;
 %end;
%mend CLUSchk1;

%macro CLUSvarschk1(name=clusvars,abbr=c,list=);
 &abbr.varbles=" ";
 %let varscnt1=1;
 %let varsnext1=%qscan(&list,&varscnt1,%str( ));
 %let &abbr.vnmerr=0;
 %do %while (&varsnext1^=);
  &abbr.varbles=&abbr.varbles//"&varsnext1";
  %let SASname=%upcase(&varsnext1);
  %if %verify(%bquote(%substr(%bquote(&SASname),1,1)),&frstchar)>0 %then %do;
   %let &abbr.vnmerr=1;
   print 
    "first character of &name variable &SASname not alphabetic or an underscore";
   inpterr=1;
  %end;
  %else %if %verify(%bquote(&SASname),&othrchar)>0 %then %do;
   %let &abbr.vnmerr=1;
   print "&name variable &SASname not a valid SAS name";
   inpterr=1;
  %end;
  %else %if %length(&SASname)>32 %then %do;
   %let &abbr.vnmerr=1;
   print "&name variable &SASname longer than 32 characters";
   inpterr=1;
  %end;
  %else %do;
   %let hold=&varsnext1;
   if all(dsvars^="%upcase(&hold)") then do;
    print (concat("nonexistent &name variable: ","&hold"));
    inpterr=1;
   end;
   else do;
    read all var {&hold} into hold;
    if type(hold)^="N" then do;
     print "nonnumeric &name variable: &hold";
     inpterr=1;
    end;
   end;
  %end;
  %let varscnt1=%eval(&varscnt1+1);
  %let varsnext1=%qscan(&list,&varscnt1,%str( ));
 %end;
 %let varscnt1=%eval(&varscnt1-1);
 %if &varscnt1>0 %then %do;
  &abbr.varbles=&abbr.varbles[2:&varscnt1+1];
 %end;
 %let &abbr.varcnt=&varscnt1;
%mend CLUSvarschk1;

%macro CLUSchk2();
 proc iml;
  reset noname;
  inpterr=0;
  %if &dspart2= %then %do;
   dslist=datasets();
   dsname="%upcase(&dspart1)";
   lbname="";
   dsvars=contents(dsname);
  %end;
  %else %do;
   dslist=datasets(&dspart1);
   lbname="%upcase(&dspart1)";
   dsname="%upcase(&dspart2)";
   dsvars=contents(lbname,dsname);
  %end;
  dsvars=upcase(dsvars);
  edit CLUS_datain var _all_;
  %CLUSnamechk(name=clstrvar,parm=&clstrvar);
  %CLUSnamechk(name=idvar,parm=&idvar,empty=0);
  %CLUSnamechk(name=bestout,parm=&bestout);
  %if ^&namerr %then %do;
   if "%upcase(%substr(&bestout.*****,1,5))"="CLUS_" then do;
    print "name of bestout data set not allowed to start with CLUS_";
    inpterr=1;
   end;
  %end;
  %CLUSnamechk(name=scoreout,parm=&scoreout);
  %if ^&namerr %then %do;
   if "%upcase(%substr(&scoreout.*****,1,5))"="CLUS_" then do;
    print "name of scoreout data set not allowed to start with CLUS_";
    inpterr=1;
   end;
  %end;
  %CLUSnamechk(name=aveyvars,parm=&aveyvars);
  %if ^&namerr %then %do;
   if "%upcase(%substr(&aveyvars.*****,1,5))"="CLUS_" then do;
    print "name of aveyvars data set not allowed to start with CLUS_";
    inpterr=1;
   end;
  %end;
  %CLUSnamechk(name=clusout,parm=&clusout);
  %if ^&namerr %then %do;
   if "%upcase(%substr(&clusout.*****,1,5))"="CLUS_" then do;
    print "name of clusout data set not allowed to start with CLUS_";
    inpterr=1;
   end;
  %end;
  %CLUSnamechk(name=treeout,parm=&treeout);
  %if ^&namerr %then %do;
   if "%upcase(%substr(&treeout.*****,1,5))"="CLUS_" then do;
    print "name of treeout data set not allowed to start with CLUS_";
    inpterr=1;
   end;
  %end;
  %if %upcase(&testcalc)=Y %then %do;
   if nclustrs=. then do;
    print "testcalc=Y not allowed with nclustrs=. to limit output";
    inpterr=1;
   end;
  %end;
  scorepos=.;
  %let xtra=%qscan(&scorefmt,3,".");
  %if %quote(&xtra)^= %then %do;
   print "too many periods in scorefmt (&scorefmt)";
   inpterr=1;
  %end;
  %if %datatyp(&scorepos)^=NUMERIC %then %do;
   print "first part of scorefmt (&scorepos) not numeric";
   inpterr=1;
  %end;
  %else %do;
   %let len=%length(&scorepos);
   %let part1=%qscan(%quote(&scorepos),1,ed);
   %if %length(&part1)<&len %then %do;
    outmess=         "first part of scorefmt (&scorepos) is in either";
    outmess=outmess//"fixed decimal or scientific notation";
    print outmess;
    inpterr=1;
   %end;
   %else %do;
    scorepos=&scorepos;
    if scorepos<=0 then do;
     print "first part of scorefmt (&scorepos) not positive";
     inpterr=1;
    end;
    else if mod(scorepos,int(scorepos))^=0 then do;
     print "first part of scorefmt (&scorepos) not an integer";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&scredgts)^=NUMERIC %then %do;
   print "second part of scorefmt (&scredgts) not numeric";
   inpterr=1;
  %end;
  %else %do;
   %let len=%length(&scredgts);
   %let part1=%qscan(%quote(&scredgts),1,.ed);
   %if %length(&part1)<&len %then %do;
    outmess=         "second part of scorefmt (&scredgts) is in either";
    outmess=outmess//"fixed decimal or scientific notation";
    print outmess;
    inpterr=1;
   %end;
   %else %do;
    scredgts=&scredgts;
    if scredgts<=0 then do;
     print "second part of scorefmt (&scredgts) not positive";
     inpterr=1;
    end;
    else if mod(scredgts,int(scredgts))^=0 then do;
     print "second part of scorefmt (&scredgts) not an integer";
     inpterr=1;
    end;
    else if scorepos^=. then do;
     if scredgts>scorepos-2 then do;
      print 
       "second part of scorefmt (&scredgts) > first part (&scorepos) - 2";
      inpterr=1;
     end;
    end;
   %end;
  %end;
  %if %upcase(&noprint)^=Y & %upcase(&noprint)^=N %then %do;
   print "noprint (&noprint) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&nolog)^=Y & %upcase(&nolog)^=N %then %do;
   print "nolog (&nolog) not Y or N";
   inpterr=1;
  %end;
  %CLUSvarschk1(name=clusvars,abbr=c,list=&clusvars);
  %CLUSvarschk1(name=xtravars,abbr=x,list=&xtravars);
  %CLUSvarschk1(name=yvars,abbr=y,list=&yvars);
  %if %quote(&near0std)^= %then %do;
   %if %datatyp(&near0std)^=NUMERIC %then %do;
    print "near0std (&near0std) not numeric";
    inpterr=1;
   %end;
   %else %do;
    near0std=&near0std;
    if near0std<=0 then do;
     print "near0std (&near0std) not positive";
     inpterr=1;
    end;
   %end;
  %end;
  %if %quote(&near0eig)^= %then %do;
   %if %datatyp(&near0eig)^=NUMERIC %then %do;
    print "near0eig (&near0eig) not numeric";
    inpterr=1;
   %end;
   %else %do;
    near0eig=&near0eig;
    if near0eig<=0 then do;
     print "near0eig (&near0eig) not positive";
     inpterr=1;
    end;
   %end;
  %end;
  %if %quote(&mindens)^= %then %do;
   %if %datatyp(&mindens)^=NUMERIC %then %do;
    print "mindens (&mindens) not numeric";
    inpterr=1;
   %end;
   %else %do;
    mindens=&mindens;
    if mindens<=0 then do;
     print "mindens (&mindens) not positive";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&decrdgts)^=NUMERIC %then %do;
   print "decrdgts (&decrdgts) not numeric";
   inpterr=1;
  %end;
  %else %do;
   %let len=%length(&decrdgts);
   %let part1=%qscan(%quote(&decrdgts),1,.ed);
   %if %length(&part1)<&len %then %do;
    print
     "decrdgts (&decrdgts) is in either fixed decimal or scientific notation";
   %end;
   %else %do;
    decrdgts=&decrdgts;
    if decrdgts<1 then do;
     print "decrdgts (&decrdgts) < 1";
     inpterr=1;
    end;
    else if mod(decrdgts,int(decrdgts))^=0 then do;
     print "decrdgts (&decrdgts) not an integer";
     inpterr=1;
    end;
   %end;
  %end;
  %if %upcase(&BIC)^=Y & %upcase(&BIC)^=N %then %do;
   print "BIC (&BIC) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if &xvrepeat^=1 & %upcase(&BIC)=Y %then %do;
    print "BIC only supported with xvrepeat=1";
    inpterr=1;
   %end;
   %if %upcase(&scretype)=PREDICTED & %upcase(&BIC)=Y %then %do;
    print 
  "Warning. BIC counts # of cluster proportions which may be inappropriate";
   %end;
  %end;
  %if %upcase(&scretype)^=EXPECTED & %upcase(&scretype)^=MIXTURE &
      %upcase(&scretype)^=PREDICTD
  %then %do;
   print "scretype (&scretype) not EXPECTED, MIXTURE, or PREDICTD";
   inpterr=1;
  %end;
  %if %upcase(&yvarnces)^=DIFF & %upcase(&yvarnces)^=SAME %then %do;
   print "yvarnces (&yvarnces) not DIFF or SAME";
   inpterr=1;
  %end;
  %if %upcase(&ycorrs)^=DIFF & %upcase(&ycorrs)^=SAME & 
      %upcase(&ycorrs)^=ZERO
  %then %do;
   print "ycorrs (&ycorrs) not DIFF, SAME, or ZERO";
   inpterr=1;
  %end;
  %if %upcase(&cvarnces)^=DIFF & %upcase(&cvarnces)^=SAME %then %do;
   print "cvarnces (&cvarnces) not DIFF or SAME";
   inpterr=1;
  %end;
  %if %upcase(&ccorrs)^=DIFF & %upcase(&ccorrs)^=SAME %then %do;
   print "ccorrs (&ccorrs) not DIFF or SAME";
   inpterr=1;
  %end;
  %if %upcase(&ycorrs)=ZERO & %upcase(&ccorrs)=DIFF %then %do;
   print "ycorrs=ZERO requires ccorrs=SAME";
   inpterr=1;
  %end;
  %if %upcase(&usenmeas)^=Y & %upcase(&usenmeas)^=N %then %do;
   print "usenmeas (&usenmeas) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&stdize)^=Y & %upcase(&stdize)^=N %then %do;
   print "stdize (&stdize) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if %quote(&clusvars)^= & %upcase(&stdize)=Y %then %do;
    print "clusvars non-empty not supported with stdize=Y";
    inpterr=1;
   %end;
   %if %quote(&stdizace)^= & %upcase(&stdize)=Y %then %do;
    print "stdizace non-empty not supported with stdize=Y";
    inpterr=1;
   %end;
   %if %quote(&stdrange)=Y & %upcase(&stdize)=Y %then %do;
    print "stdrange=Y not supported with stdize=Y";
    inpterr=1;
   %end;
  %end;
  %if %upcase(&stdrange)^=Y & %upcase(&stdrange)^=N %then %do;
   print "stdrange (&stdrange) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if %quote(&clusvars)^= & %upcase(&stdrange)=Y %then %do;
    print "clusvars not supported with stdrange=Y";
    inpterr=1;
   %end;
   %if %quote(&stdizace)^= & %upcase(&stdrange)=Y %then %do;
    print "stdizace non-empty not supported with stdrange=Y";
    inpterr=1;
   %end;
  %end;
  %if %quote(&stdizace)^= %then %do;
   %if %datatyp(&stdizace)^=NUMERIC %then %do;
    print "stdizace (&stdizace) nonnumeric";
    inpterr=1;
   %end;
   %else %do;
    stdizace=&stdizace;
    if stdizace<=0 | stdizace>=1 then do;
     print "stdizace (&stdizace) must be > 0 and < 1";
     inpterr=1;
    end;
   %end;
  %end;
  %if %upcase(&nonorm)^=Y & %upcase(&nonorm)^=N %then %do;
   print "nonorm (&nonorm) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&notie)^=Y & %upcase(&notie)^=N %then %do;
   print "notie (&notie) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&printall)^=Y & %upcase(&printall)^=N %then %do;
   print "printall (&printall) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&printall)=Y & %upcase(&noprint)=Y %then %do;
   print "printall (&printall) inconsistent with noprint (&noprint)";
   inpterr=1;
  %end;
  %if %upcase(&plotprnt)^=Y & %upcase(&plotprnt)^=N %then %do;
   print "plotprnt (&plotprnt) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&eignvals)^=Y & %upcase(&eignvals)^=N %then %do;
   print "eignvals (&eignvals) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&procmod)^=Y & %upcase(&procmod)^=N %then %do;
   print "procmod (&procmod) not Y or N";
   inpterr=1;
  %end;
  %else %do;
   %if %quote(&xtravars)^= & %upcase(&procmod)=N %then %do;
    print "xtravars not empty but procmod=N";
    inpterr=1;
   %end;
   %if %upcase(&plotprnt)=Y & %upcase(&procmod)=N %then %do;
    print "plotprnt=Y but procmod=N";
    inpterr=1;
   %end;
   %if %upcase(&eignvals)=Y & %upcase(&procmod)=N %then %do;
    print "eignvals=Y but procmod=N";
    inpterr=1;
   %end;
  %end;
  %if %upcase(&testcalc)^=Y & %upcase(&testcalc)^=N %then %do;
   print "testcalc (&testcalc) not Y or N";
   inpterr=1;
  %end;
  %if %upcase(&mlistord)^=Y & %upcase(&mlistord)^=N %then %do;
   print "mlistord (&mlistord) not Y or N";
   inpterr=1;
  %end;
  %if %datatyp(&xvrepeat)^=NUMERIC %then %do;
   print "xvrepeat (&xvrepeat) nonnumeric";
   inpterr=1;
  %end;
  %else %do;
   xvrepeat=&xvrepeat;
   if xvrepeat<1 then do;
    print "xvrepeat (&xvrepeat) less than 1";
    inpterr=1;
   end;
   else if mod(xvrepeat,int(xvrepeat))^=0 then do;
    print "xvrepeat (&xvrepeat) not an integer";
    inpterr=1;
   end;
   %if %upcase(&testcalc)=Y %then %do;
    if xvrepeat>2 then do;
     print "testcalc=Y not allowed with xvrepeat>2 to limit output";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&minprop)^=NUMERIC %then %do;
   print "minprop (&minprop) nonnumeric";
   inpterr=1;
  %end;
  %else %do;
   minprop=&minprop;
   if minprop<0 | minprop>=1 then do;
    print "minprpo (&minprop) must be >= 0 and < 1";
    inpterr=1;
   end;
  %end;
  %if %datatyp(&minsize)^=NUMERIC %then %do;
   print "minsize (&minsize) nonnumeric";
   inpterr=1;
  %end;
  %else %do;
   %let len=%length(&minsize);
   %let part1=%qscan(%quote(&minsize),1,.ed);
   %if %length(&part1)<&len %then %do;
    print
     "minsize (&minsize) is in either fixed decimal or scientific notation";
   %end;
   %else %do;
    minsize=&minsize;
    if minsize<1 then do;
     print "minsize (&minsize) less than 1";
     inpterr=1;
    end;
    else if mod(minsize,int(minsize))^=0 then do;
     print "minsize (&minsize) not an integer";
     inpterr=1;
    end;
   %end;
  %end;
  %if %datatyp(&keeplevl)^=NUMERIC %then %do;
   print "keeplevl (&keeplevl) not numeric";
   inpterr=1;
  %end;
  %else %do;
   keeplevl=&keeplevl;
   if keeplevl<0 then do;
    print "keeplevl (&keeplevl) is negative";
    inpterr=1;
   end;
   else do;
    if keeplevl>1 then do;
     print "keeplevl (&keeplevl) exceeds 1";
     inpterr=1;
    end;
   end;
  %end;
  %if %upcase(&keeptst)^=Y & %upcase(&keeptst)^=N %then %do;
   print "keeptst (&keeptst) not Y or N";
   inpterr=1;
  %end;
  %if %datatyp(&listfrom)^=NUMERIC %then %do;
   print "listfrom (&listfrom) not numeric";
   inpterr=1;
  %end;
  %else %do;
   %let len=%length(&listfrom);
   %let part1=%qscan(%quote(&listfrom),1,.ed);
   %if %length(&part1)<&len %then %do;
    print
     "listfrom (&listfrom) is in either fixed decimal or scientific notation";
   %end;
   %else %do;
    listfrom=&listfrom;
    if listfrom<0 then do;
     print "listfrom (&listfrom) is negative";
     inpterr=1;
    end;
    else if mod(listfrom,int(listfrom))^=0 then do;
     print "listfrom (&listfrom) not an integer";
     inpterr=1;
    end;
   %end;
  %end;
  methods="            "; * 12 blanks;
  %let methcnt=1;
  %let methnext=%qscan(&methlist,&methcnt,%str( ));
  %if %quote(&methnext)= %then %do;
   print "methlist is empty";
   inpterr=1;
  %end;
  EMLreqst=0;
  %do %while (%quote(&methnext)^=);
   method="%upcase(&methnext)          ";
   if method="EML" | substr(method,1,4)="EML:" then do;
    EMLreqst=1;
   end;
   methods=methods//method;
   if method^="AVERAGE" & method^="AVERNOSQ" & method^="CENTROID" &
      method^="CENTNOSQ" & method^="COMPLETE" &
      substr(method,1,7)^="DENSNN:" & substr(method,1,7)^="DENSSS:" &
      method^="EML" & method^="FLEXIBLE" & substr(method,1,4)^="EML:" &
      substr(method,1,5)^="FLEX:" & method^="KMEANS" & 
      method^="MCQUITTY" & method^="MEDIAN" & method^="MEDNNOSQ" &
      method^="SINGLE" & substr(method,1,7)^="2STGNN:" &
      substr(method,1,7)^="2STGSS:" & method^="WARD" &
      method^="WARDNOSQ"  
   then do;
    print "invalid method (&methnext)";
    inpterr=1;
   end;
   else do;
    %if %qupcase(%quote(&methnext))=EML: %then %do;
     print "method EML: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=FLEX: %then %do;
     print "method FLEX: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=DENSNN: %then %do;
     print "method DENSNN: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=DENSSS: %then %do;
     print "method DENSSS: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=2STGNN: %then %do;
     print "method 2STGNN: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %if %qupcase(%quote(&methnext))=2STGSS: %then %do;
     print "method 2STGSS: missing a value after the colon (:)";
     inpterr=1;
    %end;
    %else %do;
     %if %length(&methnext)>4 %then %do;
      %if %qupcase(%substr(%quote(&methnext),1,4))=EML: %then %do;
       %if %datatyp(%substr(&methnext,5))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        penalty=%substr(&methnext,5);
        if penalty<=0 then do;
         print "penalty in &methnext not positive";
         inpterr=1;
        end;
       %end;
      %end;
     %end;
     %if %length(&methnext)>5 %then %do;
      %if %qupcase(%substr(%quote(&methnext),1,5))=FLEX: %then %do;
       %if %datatyp(%substr(&methnext,6))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        betaval=%substr(&methnext,6);
        if betaval>=1 then do;
         print "beta value in &methnext not less than 1";
         inpterr=1;
        end;
        if betaval<-1 then do;
         print "beta value in &methnext < -1";
         inpterr=1;
        end;
       %end;
      %end;
     %end;
     %if %length(&methnext)>7 %then %do;
      %if %qupcase(%substr(%quote(&methnext),1,7))=DENSNN: |
          %qupcase(%substr(%quote(&methnext),1,7))=2STGNN:
      %then %do;
       %if %datatyp(%substr(&methnext,8))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        %let len=%length(%substr(&methnext,8));
        %let part1=%qscan(%quote(%substr(&methnext,8)),1,.ed);
        %if %length(&part1)<&len %then %do;
         outmess=         "# of nearest neighbors in &methnext is in";
         outmess=outmess//"either fixed decimal or scientific notation";
         print outmess;
        %end;
        %else %do;
         nearnbrs=%substr(&methnext,8);
         if nearnbrs<2 then do;
          print "# of nearest neighbors in &methnext not at least 2";
          inpterr=1;
         end;
         else if mod(nearnbrs,int(nearnbrs))^=0 then do;
          print "# of nearest neighbors in &methnext not an integer";
          inpterr=1;
         end; 
        %end;
       %end;
       * note that nearnbrs should also be < the # of observations;
      %end;
      %if %qupcase(%substr(%quote(&methnext),1,7))=DENSSS: |
          %qupcase(%substr(%quote(&methnext),1,7))=2STGSS:
      %then %do;
       %if %datatyp(%substr(&methnext,8))^=NUMERIC %then %do;
        print "value after colon not numeric in &methnext";
        inpterr=1;
       %end;
       %else %do;
        sphrsupp=%substr(&methnext,8);
        if sphrsupp<=0 then do;
         print "radius of sphere of support in &methnext not positive";
         inpterr=1;
        end;
       %end;
      %end;
     %end;
    %end;
   end;
   %let methcnt=%eval(&methcnt+1);
   %let methnext=%qscan(%quote(&methlist),&methcnt,%str( ));
  %end;
  %let methcnt=%eval(&methcnt-1);
  methods=methods[2:nrow(methods)];
  %if &methcnt>1 %then %do;
   uniqmeth=unique(methods);
   if nrow(methods)^=ncol(uniqmeth) then do;
    print "methlist has duplicate entries";
    inpterr=1;
   end;
   %if %upcase(&testcalc)=Y %then %do;
    print "testcalc=Y only allowed with 1 method to limit output":
    inpterr=1;
   %end;
  %end;
  %if %quote(&yvars)^= %then %do;
   %if %quote(&yfst)^= %then %do;
    print "yvars set, but yfst (&yfst) has a value";
    inpterr=1;
   %end; 
   %if %quote(&ylst)^= %then %do;
    print "yvars set, but ylst (&ylst) has a value";
    inpterr=1;
   %end;
   %if %quote(&yby)^=1 %then %do;
    print 
     "yvars set, but yby (&yby) has a value other than its default of 1";
    inpterr=1;
   %end;
   %if %quote(&yprefix)^= %then %do;
    print "yvars set, but yprefix (&yprefix) has a value";
    inpterr=1;
   %end; 
  %end;
  %else %do;
   yvarbles=" ";
   %let yvarcnt=0;
   %let allset=1;
   %if %quote(&yfst)= %then %do;
    print "no yvars list, but yfst has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %if %datatyp(&yfst)^=NUMERIC %then %do;
    print "yfst (&yfst) not numeric";
    inpterr=1;
    %let allset=0;
   %end;
   %else %if &yfst=. %then %do;
    print "yfst (&yfst) has missing value";
    inpterr=1;
    %let allset=0;
   %end;
   %if %quote(&ylst)= %then %do;
    print "no yvars list, but ylst has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %if %datatyp(&ylst)^=NUMERIC %then %do;
    print "ylst (&ylst) not numeric";
    inpterr=1;
    %let allset=0;
   %end;
   %else %if &ylst=. %then %do;
    print "ylst (&ylst) has missing value";
    inpterr=1;
    %let allset=0;
   %end;
   %if %quote(&yby)= %then %do;
    print "no yvars list, but yby has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %if %datatyp(&yby)^=NUMERIC %then %do;
    print "yby (&yby) not numeric";
    inpterr=1;
    %let allset=0;
   %end;
   %else %if &yby=. %then %do;
    print "yby (&yby) has missing value";
    inpterr=1;
    %let allset=0;
   %end;
   %if %quote(&yprefix)= %then %do;
    print "no yvars list, but yprefix has no value";
    inpterr=1;
    %let allset=0;
   %end; 
   %else %do;
    %if &allset %then %do;
     digits=ceil(int(log10(&ylst)))+1;
     mlen=32-digits;
     %CLUSnamechk(name=yprefix,parm=&yprefix,maxlen=mlen);
    %end;
    %else %do;
     %CLUSnamechk(name=yprefix,parm=&yprefix);
    %end;
    %if &namerr %then %do;
     %let allset=0;
    %end;
    %let len=%length(&yfst);
    %let part1=%qscan(%quote(&yfst),1,.ed);
    %if %length(&part1)<&len %then %do;
     print
      "yfst (&yfst) is in either fixed decimal or scientific notation";
     %let allset=0;
    %end;
    %let len=%length(&ylst);
    %let part1=%qscan(%quote(&ylst),1,.ed);
    %if %length(&part1)<&len %then %do;
     print
      "ylst (&ylst) is in either fixed decimal or scientific notation";
     %let allset=0;
    %end;
    %let len=%length(&yby);
    %let part1=%qscan(%quote(&yby),1,.ed);
    %if %length(&part1)<&len %then %do;
     print
      "yby (&yby) is in either fixed decimal or scientific notation";
     %let allset=0;
    %end;
   %end;
   %if &allset %then %do;
    yfst=&yfst;
    yfsterr=0;
    if yfst<0 then do;
     print "yfst (&yfst) less than 0";
     inpterr=1;
     yfsterr=1;
    end;
    else if mod(yfst,int(yfst))^=0 then do;
     print "yfst (&yfst) not an integer";
     inpterr=1;
     yfsterr=1;
    end;
    yby=&yby;
    ybyerr=0;
    if yby<0 then do;
     print "yby (&yby) less than 0";
     inpterr=1;
     ybyerr=1;
    end;
    else if mod(yby,int(yby))^=0 then do;
     print "yby (&yby) not an integer";
     inpterr=1;
     ybyerr=1;
    end;
    ylst=&ylst;
    if ylst<=0 then do;
     print "ylst (&ylst) not positive";
     inpterr=1;
    end;
    else do;
     if mod(ylst,int(ylst))^=0 then do;
      print "ylst (&ylst) not an integer";
      inpterr=1;
     end;
     else if ^yfsterr & ^ybyerr then do;
      if yfst>ylst then do;
       print "yfst (&yfst) larger than ylst (&ylst)";
       inpterr=1;
      end;
      else do;
       %let yvars=;
       %do if=&yfst %to &ylst %by &yby;
        if all(dsvars^="%upcase(&yprefix.&if)") then do;
         print (concat("nonexistent yprefix variable: ","&yprefix.&if"));
         inpterr=1;
        end;
        %let yvars=&yvars &yprefix.&if;
        yvarbles=yvarbles//"&yprefix.&if";
        %let yvarcnt=%eval(&yvarcnt+1);
       %end;
       yvarbles=yvarbles[2:&yvarcnt+1];
      end;
     end;
    end;
   %end;
  %end;
  if &yvarcnt>0 then do;
   if &xvarcnt > 0 then do;
    inboth=xsect(compress(upcase(yvarbles)),
                 compress(upcase(xvarbles)));  
    if ncol(inboth)>0 then do;
     %if %quote(&yprefix)^= %then %do;
      print 
       "variables based on yprefix, yfst, ylst, and yby not allowed in xtravars";
     %end;
     %else %do;
      print "yvars variables not allowed in xtravars";
     %end;
     inpterr=1;
    end;
   end;
   if &cvarcnt > 0 then do;
    inboth=xsect(compress(upcase(xvarbles)),
                 compress(upcase(cvarbles)));  
    if ncol(inboth)>0 then do;
     print  "clusvars variables not allowed in xtravars";
     inpterr=1;
    end;
   end;
  end;
  if inpterr then do;
   print "execution canceled";
  end;
  abort=inpterr;
  call symput("abort",compress(char(abort)));
  call symput("EMLreqst",compress(char(EMLreqst)));
 quit;
 %if ^&abort %then %do;
  data CLUS_datain;
   set CLUS_datain;
   %if %upcase(&BIC)^=Y %then %do;
    %do ixv=1 %to &xvrepeat;
     CLUS_randno&ixv=.;
     CLUS_fold&ixv=.;
    %end;
   %end;
   %else %do;
    CLUS_randno1=.;
    CLUS_fold1=1;
   %end;
  run;
  %if %upcase(&BIC)^=Y %then %do;
   proc iml;
    reset noname; * turn off when testing so names come out in prints;
    edit CLUS_datain var _all_;
    %do ixv=1 %to &xvrepeat;
     read all var {CLUS_randno&ixv,CLUS_fold&ixv};
    %end;
    nobs=nrow(CLUS_fold1);
    * the following approach for generating the fold assignments
      guarantees that fold assignments for lower xvrepeat values
      agree with the first so many fold assignments for larger
      xvrepeat values
    ;
    %do ixv=1 %to &xvrepeat;
     do iy=1 to nobs;
      * note that even though the same value of &initseed
        is used in each of these assignment statements
        an updated value of the seed is used after the
        first invocation
      ;
      CLUS_randno&ixv[iy]=uniform(&initseed);
     end;
     CLUS_fold&ixv=int(CLUS_randno&ixv*&foldcnt)+1;
    %end;
    %if &foldcnt=1 %then %do;
     %do ixv=1 %to &xvrepeat;
      randordr=rank(CLUS_randno&ixv);
      ind=(randordr>&holdout*nobs);
      * fold is left equal to 1 on the first &holdout*100% of
        the observations to represent the holdout set and is
        changed to 2 on the rest of the observations to
        represent the training set
      ;
      CLUS_fold&ixv=CLUS_fold&ixv+ind;
      replace all var {CLUS_fold&ixv};
     %end;
    %end;
    %do ixv=1 %to &xvrepeat;
     replace all var {CLUS_randno&ixv,CLUS_fold&ixv};
    %end;
   quit;
  %end;
  proc sort;
   by &yvars;
  run;
  data CLUS_datain;
   set CLUS_datain;
   drop %do ixv=1 %to &xvrepeat;
         CLUS_randno&ixv
        %end;
   ;
  run;
  proc iml;
   reset noname; * turn off when testing so names come out in prints;
   abort=0;
   edit CLUS_datain var _all_;
   read all var {&yvars} into y;
   ny=nrow(y);
   yvarcnt=ncol(y);
   nmeas=(y^=.)[+];
   nmiss=(y=.)[+];
   * observations with exactly the same yvars values are
     assigned to the same fold
   ;
   anymiss=0;
   if any(y=.) then do;
    anymiss=1;
    misscont=1;
    do iy=1 to ny while(misscont);
     if all(y[iy,]=.) then do;
      print "some subjects have all their yvars values missing";
      abort=1;
      misscont=0;
     end;
    end;
    %if %quote(%upcase(&methlist))^=KMEANS %then %do;
     overlap=1;
     if anymiss then do;
      do i1=1 to ny-1 while (overlap);
       do i2=i1+1 to ny while (overlap);
        if all(y[i1,]#y[i2,]=.) then do;
         print 
          "some pairs of subjects have no non-missing y values in common";
         abort=1;
         overlap=0;
        end;
       end;
      end;
     end;
    %end;
    %if %quote(&stdizace)^= %then %do;
     print "stdizace not supported with missing yvars values";
     abort=1;
    %end;
    %if %quote(&stdize)=Y %then %do;
     print "stdize=Y not supported with missing yvars values";
     abort=1;
    %end;
    %if &EMLreqst %then %do; 
     print "EML not supported with missing yvars values";
     abort=1;
    %end;
   end;
   continue=1;
   %let ixv=0;
   %do ixv=1 %to &xvrepeat;
    if continue then do;
     read all var {CLUS_fold&ixv};
     do iy=2 to ny;
      if y[iy,]=y[iy-1,] then
       CLUS_fold&ixv[iy]=CLUS_fold&ixv[iy-1];
     end;
     replace all var {CLUS_fold&ixv};
     foldcnt=repeat(0,&foldcnt,1);
     %do ifold=1 %to &foldcnt;
      foldcnt[&ifold]=(CLUS_fold&ixv=&ifold)[+];
     %end;
     emptyflds=(foldcnt=0)[+];
     maxfsize=foldcnt[<>];
     %if %upcase(&BIC)^=Y %then %do;
      if maxfsize=ny then do;
       print "all observations in the same fold for xvrepeat=&ixv";
       abort=1;
       continue=0;
      end;
      if &nlst>ny-maxfsize then do;
       print "# of clusters can get too large to compute LCV scores";
       abort=1;
       continue=0;
      end;
     %end;
     %do ifold=1 %to &foldcnt;
      call symput("fldsiz&ifold._&ixv",compress(char(foldcnt[&ifold])));
     %end;
     * not currently using these macro parameters , but left in for
       for possible later use
     ;
     call symput("empflds&ixv",compress(char(emptyflds)));
     %if &foldcnt=1 & &ixv=1 & %upcase(&BIC)^=Y %then %do;
      if maxfsize=0 then do;
       print "the single fold is empty";
       abort=1;
       continue=0;
      end;
     %end;
    end; * end of continue check;
   %end;
   %if &foldcnt=1 %then %do;
    testcnt=ny-foldcnt[1];
   %end;
   %else %do;
    testcnt=ny;
   %end;
   %if %upcase(&keeptst)=Y %then %do;
    * DF computed as change in # of paramters witjh 1 less cluster;
    %if %upcase(&ccorrs)=SAME %then %do;
     %if %upcase(&cvarnces)=SAME %then %do;
      * change in # of parameters 0, so use smallest possible DF;
      DF=1;
     %end;
     %else %do;
      * 1 less variance for each yvars variable;
      DF=yvarcnt;
     %end;
    %end;
    %else %do;
     %if %upcase(&cvarnces)=SAME %then %do;
      * 1 less correlation for each distinct pair of yvar variables;
      DF=yvarcnt*(yvarcnt-1)/2;
     %end;
     %else %do;
      * 1 less covariance for each pair of yvars variable;
      DF=yvarcnt*(yvarcnt+1)/2;
     %end;
    %end;
    keepval=1-exp(-cinv(0.95,DF)/(2*nmeas))*&keeplevl/0.02;
   %end;
   %else %do;
    keepval=&keeplevl;
   %end;
   %if %quote(&outlib)^= %then %do;
    %if %upcase(&procmod)=N %then %do;
     print "a non-empty outlib value requires procmod=Y";
     abort=1;
    %end;
    libname CLUS_out "&outlib";
   %end;
   call symput("obscnt",compress(char(ny)));
   call symput("yvarcnt",compress(char(yvarcnt)));
   call symput("testcnt",compress(char(testcnt)));
   call symput("anymiss",compress(char(anymiss)));
   call symput("abort",compress(char(abort)));
   call symput("keepval",compress(char(keepval)));
   call symput("nmeas",compress(char(nmeas)));
   call symput("nmiss",compress(char(nmiss)));
   call symput("DF",compress(char(DF)));
  quit;
  %if ^&abort %then %do;
   data CLUS_datain;
    set CLUS_datain;
    %if %quote(&subsetvr)^= %then %do;
     if &subsetvr;
    %end;
    %if %upcase(&stdize)=Y | %upcase(&stdrange)=Y | %quote(&stdizace)^=
    %then %do;
     %do ivar=1 %to &yvarcnt;
      _ystd_&ivar=.;
      %let clusvars=&clusvars _ystd_&ivar;
     %end;
    %end;
   run;
   %if %upcase(&stdize)=Y | %upcase(&stdrange)=Y %then %do;
    proc iml;
     reset noname; * turn off when testing so names come out in prints;
     edit CLUS_datain var _all_;
     read all var {&yvars} into y;
     ny=nrow(y);
     * handle stdize=Y if necessary;
     %if %upcase(&stdize)=Y %then %do;
      read all var {&clusvars};
      %do ivar=1 %to &yvarcnt;
       _ystd_&ivar=y[,&ivar];
      %end;
      replace all var {&clusvars};
     %end;
     %if %upcase(&stdrange)=Y %then %do;
      read all var {&clusvars};
      miny=y[><,];
      maxy=y[<>,];
      %do ivar=1 %to &yvarcnt;
       if maxy[1,&ivar]>miny[1,&ivar] then do;
        _ystd_&ivar=(y[,&ivar]-miny[1,&ivar])/(maxy[1,&ivar]-miny[1,&ivar]);
       end;
       else do;
        ny=nrow(y);
        _ystd_&ivar=repeat(.,ny,1);
        _ystd_&ivar[loc(y[,&ivar]^=.)]=1; 
            * using 1 as the lim(x/x) as x converges to 0;
       end;
      %end;
      replace all var {&clusvars};
     %end;
    quit;
   %end;
  %end;
 %end;
%mend CLUSchk2;

%macro CLUSprints();
 proc iml;
  reset noname;
  print "LCVcluster version date:          &version";
  cname1="data set";
  cname2="name";
  data1={"aveyvars:","bestout:","clusout:","datain:","scoreout:"};
  data2={"&aveyvars","&bestout","&clusout","&datain","&scoreout"};
  print data1[colname=cname1] "        " data2[colname=cname2];
  varsin={"&clstrvar","--","--"};
  typein={"clstrvar:","idvar:","subsetvr:"};
  %if %quote(&idvar)^= %then %do;
   varsin[2]="&idvar";
  %end;
  %if %quote(&subsetvr)^= %then %do;
   varsin[3]="&subsetvr";
  %end;
  cname1="variable";
  cname2="name";
  print typein[colname=cname1] "        " varsin[colname=cname2];
  cntmess=         "# of observed vectors:               &obscnt";
  cntmess=cntmess//"# of outcome variables:              &yvarcnt";
  cntmess=cntmess//"# of observed measurements:          &nmeas";
  cntmess=cntmess//"# of missing measurements:           &nmiss";
  print cntmess;
  %if %quote(&outlib)= %then %do;
   print "empty outlib setting";
  %end;
  %else %do;
   outlmess="&outlib";
   cname="outlib";
   len=nleng(outlmess)-nleng(cname);
   if len>0 then do;
    len2=int(len/2);
    if len2>0 then do;
     cname=concat(cshape(" ",1,1,len2),cname);
    end;
   end;
   print outlmess[colname=cname];
  %end;
  %CLUSvarsld1(name=clusvars,abbr=c,list=&clusvars);
  %if &cvarcnt=0 %then %do;
   print "empty clusvars setting";
  %end;
  %else %do;
   cname="clusvars";
   termlen=nleng(cvarbles);
   perline=int(40/termlen);
   linecnt=int(&cvarcnt/perline);
   if perline=1 then do;
    cout=cvarbles;
   end;
   else do;
    chold=cvarbles[1];
    itmax=min(perline,&cvarcnt);
    do it=2 to itmax;
     chold=concat(chold," ",cvarbles[it]);
    end;
    cout=chold;
    prior=itmax;
    do il=2 to linecnt;
     chold=cvarbles[prior+1];
     do it=2 to perline;
      chold=concat(chold," ",cvarbles[prior+it]);
     end;
     cout=cout//chold;
     prior=prior+perline;
    end;
    if prior<&cvarcnt then do;
     chold=cvarbles[prior+1];
     do it=prior+2 to &cvarcnt;
      chold=concat(chold," ",cvarbles[it]);
     end;
     cout=cout//chold;
    end;
   end;
   len=nleng(cout)-nleng(cname);
   if len>0 then do;
    len2=int(len/2);
    if len2>0 then do;
     cname=concat(cshape(" ",1,1,len2),cname);
    end;
   end;
   print cout[colname=cname];
  %end;
  %CLUSvarsld1(name=xtravars,abbr=x,list=&xtravars);
  %if &xvarcnt=0 %then %do;
   print "empty xtravars setting";
  %end;
  %else %do;
   cname="xtravars";
   termlen=nleng(xvarbles);
   perline=int(40/termlen);
   linecnt=int(&xvarcnt/perline);
   if perline=1 then do;
    xout=xvarbles;
   end;
   else do;
    xhold=xvarbles[1];
    itmax=min(perline,&xvarcnt);
    do it=2 to itmax;
     xhold=concat(xhold," ",xvarbles[it]);
    end;
    xout=xhold;
    prior=itmax;
    do il=2 to linecnt;
     xhold=xvarbles[prior+1];
     do it=2 to perline;
      xhold=concat(xhold," ",xvarbles[prior+it]);
     end;
     xout=xout//xhold;
     prior=prior+perline;
    end;
    if prior<&xvarcnt then do;
     xhold=xvarbles[prior+1];
     do it=prior+2 to &xvarcnt;
      xhold=concat(xhold," ",xvarbles[it]);
     end;
     xout=xout//xhold;
    end;
   end;
   len=nleng(xout)-nleng(cname);
   if len>0 then do;
    len2=int(len/2);
    if len2>0 then do;
     cname=concat(cshape(" ",1,1,len2),cname);
    end;
   end;
   print xout[colname=cname];
  %end;
  %if %quote(&yprefix)^= %then %do;
   yvarmess="&yprefix&yfst to &yprefix&ylst by steps of size &yby ";
   cname="yvars";
   len=nleng(yvarmess)-nleng(cname);
   if len>0 then do;
    len2=int(len/2);
    if len2>0 then do;
     cname=concat(cshape(" ",1,1,len2),cname);
    end;
   end;
   print yvarmess[colname=cname];
  %end;
  %else %do;
   %CLUSvarsld1(name=yvars,abbr=y,list=&yvars);
   cname="yvars";
   termlen=nleng(yvarbles);
   perline=int(40/termlen);
   linecnt=int(&yvarcnt/perline);
   if perline=1 then do;
    yout=yvarbles;
   end;
   else do;
    yhold=yvarbles[1];
    itmax=min(perline,&yvarcnt);
    do it=2 to itmax;
     yhold=concat(yhold," ",yvarbles[it]);
    end;
    yout=yhold;
    prior=itmax;
    do il=2 to linecnt;
     yhold=yvarbles[prior+1];
     do it=2 to perline;
      yhold=concat(yhold," ",yvarbles[prior+it]);
     end;
     yout=yout//yhold;
     prior=prior+perline;
    end;
    if prior<&yvarcnt then do;
     yhold=yvarbles[prior+1];
     do it=prior+2 to &yvarcnt;
      yhold=concat(yhold," ",yvarbles[it]);
     end;
     yout=yout//yhold;
    end;
   end;
   len=nleng(yout)-nleng(cname);
   if len>0 then do;
    len2=int(len/2);
    if len2>0 then do;
     cname=concat(cshape(" ",1,1,len2),cname);
    end;
   end;
   print yout[colname=cname];
  %end;
  %CLUSvarsld1(name=methlist,abbr=m,list=&methlist);
  cname="methlist";
  termlen=nleng(mvarbles);
  perline=int(40/termlen);
  linecnt=int(&mvarcnt/perline);
  if perline=1 then do;
   mout=mvarbles;
  end;
  else do;
   mhold=mvarbles[1];
   itmax=min(perline,&mvarcnt);
   do it=2 to itmax;
    mhold=concat(mhold," ",mvarbles[it]);
   end;
   mout=mhold;
   prior=itmax;
   do il=2 to linecnt;
    mhold=mvarbles[prior+1];
    do it=2 to perline;
     mhold=concat(mhold," ",mvarbles[prior+it]);
    end;
    mout=mout//mhold;
    prior=prior+perline;
   end;
   if prior<&mvarcnt then do;
    mhold=mvarbles[prior+1];
    do it=prior+2 to &mvarcnt;
     mhold=concat(mhold," ",mvarbles[it]);
    end;
    mout=mout//mhold;
   end;
  end;
  len=nleng(mout)-nleng(cname);
  if len>0 then do;
   len2=int(len/2);
   if len2>0 then do;
    cname=concat(cshape(" ",1,1,len2),cname);
   end;
  end;
  print mout[colname=cname];
  cname=             "correlation settings";
  corrmess=          "ccorrs:            &ccorrs";
  corrmess=corrmess//"cvarnces:          &cvarnces";
  corrmess=corrmess//"ycorrs:            &ycorrs";
  corrmess=corrmess//"yvarnces:          &yvarnces";
  len=nleng(corrmess)-nleng(cname);
  if len>0 then do;
   len2=int(len/2);
   if len2>0 then do;
    cname=concat(cshape(" ",1,1,len2),cname);
   end;
  end;
  print corrmess[colname=cname];
  cname=              "control settings";
  contmess=           "maxnclus:          &maxnclus";
  contmess=contmess// "mindens:           &mindens";
  contmess=contmess// "minnclus:          &minnclus";
  contmess=contmess// "minprop:           &minprop";
  contmess=contmess// "minsize:           &minsize";
  contmess=contmess// "nclustrs:          &nclustrs";
  contmess=contmess// "near0eig:          &near0eig";
  contmess=contmess// "near0std:          &near0std";
  contmess=contmess// "nonorm:            &nonorm";
  contmess=contmess// "notie:             &notie";
  %if %quote(&stdizace)^= %then %do;
   contmess=contmess//"stdizace:          &stdizace";
  %end;
  %else %do;
   contmess=contmess//"stdizace:          --";
  %end;
  contmess=contmess// "stdize:            &stdize";
  contmess=contmess// "stdrange:          &stdrange";
  len=nleng(contmess)-nleng(cname);
  if len>0 then do;
   len2=int(len/2);
   if len2>0 then do;
    cname=concat(cshape(" ",1,1,len2),cname);
   end;
  end;
  print contmess[colname=cname];
  cname=          "cross-validation settings";
  cvmess=         "BIC:                            &BIC";
  %if %quote(&BIC)=Y %then %do;
   cvmess=cvmess//"usenmeas:                       &usenmeas";
  %end;
  cvmess=cvmess// "foldcnt:                        &foldcnt";
  %if %quote(&holdout)^= %then %do;
   cvmess=cvmess//"holdout:                        &holdout";
  %end;
  %else %do;
   cvmess=cvmess//"holdout:                        --";
  %end;
  cvmess=cvmess// "initseed:                       &initseed";
  cvmess=cvmess// "keeplevl:                       &keeplevl";
  cvmess=cvmess// "keeptst:                        &keeptst";
  cvmess=cvmess// "scretype:                       &scretype";
  cvmess=cvmess// "xvrepeat:                       &xvrepeat";
  cvmess=cvmess// 
           concat("percent decrease cutoff:        ",char(100*&keepval,8),"%");
  cvmess=cvmess// "degrees of freedom for cutoff:  &DF";
  len=nleng(cvmess)-nleng(cname);
  if len>0 then do;
   len2=int(len/2);
   if len2>0 then do;
    cname=concat(cshape(" ",1,1,len2),cname);
   end;
  end;
  print cvmess[colname=cname]; 
 quit;
%mend CLUSprints;
